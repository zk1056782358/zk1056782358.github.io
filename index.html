<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/20/D-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/D-Pointer/" class="post-title-link" itemprop="url">D-Pointer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-20 22:49:44" itemprop="dateCreated datePublished" datetime="2022-09-20T22:49:44+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-24 12:11:20" itemprop="dateModified" datetime="2022-09-24T12:11:20+08:00">2022-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/QT/" itemprop="url" rel="index"><span itemprop="name">QT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="What-is-the-d-pointer"><a href="#What-is-the-d-pointer" class="headerlink" title="What is the d-pointer"></a>What is the d-pointer</h3><p>If you have looked into Qt source files like <a href="http://code.qt.io/cgit/qt/qtbase.git/tree/src/widgets/widgets/qlabel.cpp" target="_blank" rel="noopener">this one</a>, you will find it generously sprinkled with <code>Q_D</code> and <code>Q_Q</code> macros. This article unravels the purpose of these macros.</p>
<p>The <code>Q_D</code> and <code>Q_Q</code> macros are part of a design pattern called the <em>d-pointer</em> (also called the <em><a href="http://en.wikipedia.org/wiki/Opaque_pointer" target="_blank" rel="noopener">opaque pointer</a></em>) where the implementation details of a library may be hidden from its users and changes to the implementation can be made to a library without breaking binary compatibility.</p>
<p>如果您查看过类似这样的 Qt 源文件，您会发现它大量使用了 Q_D 和 Q_Q 宏。 本文揭示了这些宏的用途。</p>
<p>Q_D 和 Q_Q 宏是称为 d 指针（也称为不透明指针）的设计模式的一部分，其中库的实现细节可能对其用户隐藏，并且可以在不破坏二进制文件的情况下对库进行实现更改 兼容性。</p>
<h3 id="Binary-compatibility-—-what-is-that"><a href="#Binary-compatibility-—-what-is-that" class="headerlink" title="Binary compatibility — what is that?"></a>Binary compatibility — what is that?</h3><p>When designing libraries like Qt, it is desirable that applications that dynamically link to Qt continue to run without recompiling even after the Qt library is upgraded/replaced with another version. For example, if your application <em>CuteApp</em> was based on Qt 4.5, you should be able to upgrade the Qt libraries (on Windows shipped with the application, on Linux often comes from package manager automatically!) from version 4.5 to Qt 4.6 and your CuteApp that was built with Qt 4.5 should still be able to run.</p>
<p>在设计像 Qt 这样的库时，即使在 Qt 库升级/替换为另一个版本之后，动态链接到 Qt 的应用程序也希望在不重新编译的情况下继续运行。 例如，如果您的应用程序 CuteApp 基于 Qt 4.5，您应该能够将 Qt 库（在应用程序附带的 Windows 上，在 Linux 上通常自动来自包管理器！）从版本 4.5 升级到 Qt 4.6 和您的 CuteApp 用 Qt 4.5 构建的应该仍然可以运行。</p>
<h3 id="What-breaks-binary-compatibility"><a href="#What-breaks-binary-compatibility" class="headerlink" title="What breaks binary compatibility?"></a>What breaks binary compatibility?</h3><p>So, when does a change in the library require a recompilation of the application? Let’s take a simple example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    Rect m_geometry;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_text;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">String</span> m_text;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>Here we have a Widget that contains geometry as a member variable. We compile our Widget and ship it as <em>WidgetLib 1.0</em>.</p>
<p>For <em>WidgetLib 1.1</em>, someone comes up with the bright idea to add support for stylesheets. No sweat, we just add new methods and add a new <em>data member</em>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     Rect m_geometry;</span><br><span class="line">     <span class="keyword">String</span> m_stylesheet; <span class="comment">// NEW in WidgetLib 1.1</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">     <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> m_text;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">String</span> m_text;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>We ship WidgetLib 1.1 with the above change only to find that CuteApp that was compiled and ran just fine with WidgetLib 1.0 crashes gloriously!</p>
<h3 id="Why-did-it-crash"><a href="#Why-did-it-crash" class="headerlink" title="Why did it crash?"></a>Why did it crash?</h3><p>The reason is that by adding a new data member, we ended up changing the size of Widget and Label objects. Why does this matter? When your C++ compiler generates code, it uses <strong>offsets</strong> to access data within an object.</p>
<p>Here’s an oversimplified version of how the above <a href="https://en.wikipedia.org/wiki/Passive_data_structure" target="_blank" rel="noopener">POD</a> objects might look in memory.</p>
<table>
<thead>
<tr>
<th align="center">Label object layout in WidgetLib 1.0</th>
<th align="center">Label object layout in WidgetLib 1.1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m_geometry &lt;offset 0&gt;</td>
<td align="center">m_geometry &lt;offset 0&gt;</td>
</tr>
<tr>
<td align="center">- - -</td>
<td align="center">m_stylesheet &lt;offset 1&gt;</td>
</tr>
<tr>
<td align="center">m_text &lt;offset 1&gt;</td>
<td align="center">- - -</td>
</tr>
<tr>
<td align="center">- - -</td>
<td align="center">m_text &lt;offset 2&gt;</td>
</tr>
</tbody></table>
<p>In WidgetLib 1.0, the text member of Label was at (logical) offset 1. The code generated by the compiler in the application for the method <code>Label::text()</code> translates to accessing offset 1 of the label object in the application. In WidgetLib 1.1, the <em>text</em> member of Label has shifted to (logical) offset 2! Since the application has not been recompiled, it continues to think that <code>text</code> is at offset 1 and ends up accessing the <code>stylesheet</code> variable!</p>
<p>I am sure at this point there are a few who are wondering why the <code>Label::text()</code>‘s offset calculation code ended up in the CuteApp binary and not in the WidgetLib binary. The answer is that the code for <code>Label::text()</code> was defined in the header file and the compiler ended up <em><a href="http://en.wikipedia.org/wiki/Inline_function" target="_blank" rel="noopener">inlining</a></em> it.</p>
<p>So, does the situation change if <code>Label::text()</code> had not been inlined? Say, <code>Label::text()</code> was moved to the source file? Well, no. The C++ compiler relies on the size of objects being the same at compile time and run-time. For example, stack winding/unwinding - if you created a Label object on the stack, the compiler generated code to allocate space on the stack based on the Label’s size at compile time. Since the size of Label is different at run time in WidgetLib 1.1, Label’s constructor overwrites existing stack data and ends up corrupting the stack.</p>
<p>在 WidgetLib 1.0 中，Label 的文本成员位于（逻辑）偏移量 1。编译器在应用程序中为方法 Label::text() 生成的代码转换为访问应用程序中标签对象的偏移量 1。在 WidgetLib 1.1 中，Label 的文本成员已移动到（逻辑）偏移量 2！由于应用程序尚未重新编译，它继续认为文本位于偏移量 1 并最终访问样式表变量！</p>
<p>我敢肯定，在这一点上，有些人想知道为什么 Label::text() 的偏移量计算代码最终出现在 CuteApp 二进制文件中，而不是 WidgetLib 二进制文件中。答案是 Label::text() 的代码是在头文件中定义的，编译器最终内联了它。</p>
<p>那么，如果 Label::text() 没有被内联，情况会改变吗？说，Label::text() 被移动到源文件？嗯，不。 C++ 编译器依赖于对象的大小在编译时和运行时相同。例如，堆栈卷绕/展开 - 如果您在堆栈上创建了一个标签对象，编译器会生成代码以在编译时根据标签的大小在堆栈上分配空间。由于在 WidgetLib 1.1 中运行时 Label 的大小不同，Label 的构造函数会覆盖现有的堆栈数据并最终破坏堆栈。</p>
<h3 id="Never-change-the-size-of-an-exported-C-class"><a href="#Never-change-the-size-of-an-exported-C-class" class="headerlink" title="Never change the size of an exported C++ class"></a>Never change the size of an exported C++ class</h3><p>In summary, never ever change the size or layout (don’t move the data around) of <em>exported</em> (i.e visible to the user) C++ classes once your library has been released. A C++ compiler generates code assuming that the size or the ordering of data in a class does not change <em>after</em> the application has been compiled.</p>
<p>So, how can one not change the size of the object and yet add new features?</p>
<p>总之，一旦你的库发布，永远不要改变导出的（即对用户可见的）C++ 类的大小或布局（不要移动数据）。 C++ 编译器生成代码时假定类中数据的大小或顺序在应用程序编译完成后不会改变。</p>
<p>那么，如何既不改变对象的大小又增加新的特征呢？</p>
<h3 id="The-d-pointer"><a href="#The-d-pointer" class="headerlink" title="The d-pointer"></a>The d-pointer</h3><p>The trick is to keep the size of all public classes of a library constant by only storing a single pointer. This pointer points to a private/internal data structure that contains all the data. The size of this internal structure can shrink or grow without having any side-effect on the application because the pointer is accessed only in the library code and from the application’s point of view the size of the object never changes - it’s always the size of the pointer. This pointer is called the d-pointer.</p>
<p>The spirit of this pattern is outlined in the code below (all code in this article doesn’t have destructors, of course you should add them in real code).</p>
<p>诀窍是通过仅存储单个指针来保持库的所有公共类的大小不变。 该指针指向包含所有数据的私有/内部数据结构。 这个内部结构的大小可以缩小或增长，而不会对应用程序产生任何副作用，因为指针只能在库代码中访问，从应用程序的角度来看，对象的大小永远不会改变 - 它始终是 指针。 该指针称为 d 指针。</p>
<p>这种模式的精神在下面的代码中进行了概述（本文中的所有代码都没有析构函数，当然你应该在实际代码中添加它们）。</p>
<h4 id="widget-h"><a href="#widget-h" class="headerlink" title="widget.h"></a><strong>widget.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Since d_ptr is a pointer and is never referended in header file</span></span><br><span class="line"><span class="comment">(it would cause a compile error) WidgetPrivate doesn't have to be included,</span></span><br><span class="line"><span class="comment">but forward-declared instead.</span></span><br><span class="line"><span class="comment">The definition of the class can be written in widget.cpp or</span></span><br><span class="line"><span class="comment">in a separate file, say widget_p.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetPrivate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Rect <span class="title">geometry</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-p-h"><a href="#widget-p-h" class="headerlink" title="widget_p.h"></a><strong>widget_p.h</strong></h4><p>which is the private header file of the widget class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* widget_p.h (_p means private) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Rect geometry;</span><br><span class="line">    <span class="keyword">String</span> stylesheet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp"><a href="#widget-cpp" class="headerlink" title="widget.cpp"></a><strong>widget.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With this #include, we can access WidgetPrivate.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget_p.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget() : d_ptr(<span class="keyword">new</span> WidgetPrivate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Creation of private data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">Widget::geometry</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The d-ptr is only accessed in the library code</span></span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;geometry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, there’s an example of a child class based on Widget.</p>
<h4 id="label-h"><a href="#label-h" class="headerlink" title="label.h"></a><strong>label.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Each class maintains its own d-pointer</span></span><br><span class="line">    LabelPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="label-cpp"><a href="#label-cpp" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike WidgetPrivate, the author decided LabelPrivate</span></span><br><span class="line"><span class="comment">// to be defined in the source file itself</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LabelPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::Label() : d_ptr(<span class="keyword">new</span> LabelPrivate)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">Label::text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;<span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With the above structure, CuteApp never accesses the d-pointer directly. And since the <em>d-pointer</em> is only ever accessed in WidgetLib and WidgetLib is recompiled for every release, the Private class can freely change with no impact on CuteApp.</p>
<p>使用上述结构，CuteApp 永远不会直接访问 d 指针。 由于 d-pointer 只能在 WidgetLib 中访问，并且每次发布都会重新编译 WidgetLib，因此 Private 类可以自由更改，而不会影响 CuteApp。</p>
<h3 id="Other-benefits-of-d-pointer"><a href="#Other-benefits-of-d-pointer" class="headerlink" title="Other benefits of d-pointer"></a>Other benefits of d-pointer</h3><p>It’s not all about binary compatibility. The d-pointer has other benefits:</p>
<ul>
<li>Hide implementation details - We can ship WidgetLib with just the header files and the binaries. The .cpp files can be closed source.</li>
<li>The header file is clean of implementation details and can serve as the API reference.</li>
<li>Since the header files needed for implementation are moved from the header file into the implementation (source) file, compiles are much faster.</li>
</ul>
<p>It is indeed true that the above benefits appear trivial. The real reason to use d-pointers in Qt is for binary compatibility and the fact that Qt started out closed source.</p>
<ul>
<li>隐藏实现细节 - 我们可以只使用头文件和二进制文件来发布 WidgetLib。 .cpp 文件可以是封闭源代码。</li>
<li>头文件没有实现细节，可以作为 API 参考。</li>
<li>由于实现所需的头文件从头文件移动到实现（源）文件，编译速度更快。</li>
</ul>
<p>确实，上述好处似乎微不足道。 在 Qt 中使用 d 指针的真正原因是为了二进制兼容性以及 Qt 开始是封闭源代码的事实。</p>
<h3 id="The-q-pointer"><a href="#The-q-pointer" class="headerlink" title="The q-pointer"></a>The q-pointer</h3><p>So far, we have only seen the d-pointer as a C-style data structure. In reality, it contains private methods (helper functions). For example, <code>LabelPrivate</code> might have a <code>getLinkTargetFromPoint()</code> helper function that is required to find the link target when the mouse is clicked. In many cases, these helper methods require access to the public class i.e some functions from Label or from its base class Widget. For example, a helper method, <code>setTextAndUpdateWidget()</code> might want to call <code>Widget::update()</code> which is a public method to schedule a redraw the Widget. So, the <code>WidgetPrivate</code> stores a pointer to the public class called the q-pointer. Modifying the code above for the q-pointer, we get:</p>
<p>到目前为止，我们只将 d 指针视为 C 风格的数据结构。 实际上，它包含私有方法（辅助函数）。 例如，LabelPrivate 可能有一个 getLinkTargetFromPoint() 辅助函数，当单击鼠标时需要它来查找链接目标。 在许多情况下，这些辅助方法需要访问公共类，即来自 Label 或其基类 Widget 的一些函数。 例如，一个辅助方法 setTextAndUpdateWidget() 可能想要调用 Widget::update() 这是一个公共方法来安排重绘 Widget。 因此，WidgetPrivate 存储了一个指向名为 q-pointer 的公共类的指针。 修改上面的 q-pointer 代码，我们得到：</p>
<h4 id="widget-h-1"><a href="#widget-h-1" class="headerlink" title="widget.h"></a><strong>widget.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetPrivate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Rect <span class="title">geometry</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-p-h-1"><a href="#widget-p-h-1" class="headerlink" title="widget_p.h"></a><strong>widget_p.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Constructor that initializes the q-ptr</span></span><br><span class="line">    WidgetPrivate(Widget *q) : q_ptr(q) &#123; &#125;</span><br><span class="line">    Widget *q_ptr; <span class="comment">// q-ptr points to the API class</span></span><br><span class="line">    Rect geometry;</span><br><span class="line">    <span class="keyword">String</span> stylesheet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp-1"><a href="#widget-cpp-1" class="headerlink" title="widget.cpp"></a><strong>widget.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget_p.h"</span></span></span><br><span class="line"><span class="comment">// Create private data.</span></span><br><span class="line"><span class="comment">// Pass the 'this' pointer to initialize the q-ptr</span></span><br><span class="line">Widget::Widget() : d_ptr(<span class="keyword">new</span> WidgetPrivate(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">Widget::geometry</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// the d-ptr is only accessed in the library code</span></span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;geometry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, another class based on Widget.</p>
<h4 id="label-h-1"><a href="#label-h-1" class="headerlink" title="label.h"></a><strong>label.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LabelPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="label-cpp-1"><a href="#label-cpp-1" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike WidgetPrivate, the author decided LabelPrivate</span></span><br><span class="line"><span class="comment">// to be defined in the source file itself</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LabelPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LabelPrivate(Label *q) : q_ptr(q) &#123; &#125;</span><br><span class="line">    Label *q_ptr;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::Label() : d_ptr(<span class="keyword">new</span> LabelPrivate(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">Label::text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;<span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inheriting-d-pointers-for-optimization"><a href="#Inheriting-d-pointers-for-optimization" class="headerlink" title="Inheriting d-pointers for optimization"></a>Inheriting d-pointers for optimization</h3><p>In the above code, creating a single Label results in the memory allocation for <code>LabelPrivate</code> and <code>WidgetPrivate</code>. If we were to employ this strategy for Qt, the situation becomes quite worse for classes like <code>QListWidget</code> - it is 6 levels deep in the class inheritance hierarchy and it would result in upto 6 memory allocations!</p>
<p>This is solved by having an inheritance hierarchy for our <em>private</em> classes and having the class getting instantiated pass on a the d-pointer all the way up.</p>
<p>Notice that when inheriting d-pointers, the declaration of the private class has to be in a separate file, for example widget_p.h. It’s no longer possible to declare it in the widget.cpp file.</p>
<p>在上面的代码中，创建单个 Label 会导致 LabelPrivate 和 WidgetPrivate 的内存分配。 如果我们对 Qt 采用这种策略，那么对于像 QListWidget 这样的类，情况会变得更糟——它在类继承层次结构中有 6 层，最多会导致 6 次内存分配！</p>
<p>这可以通过为我们的私有类建立一个继承层次结构并让被实例化的类一直传递到 d 指针来解决。</p>
<p>请注意，当继承 d 指针时，私有类的声明必须在单独的文件中，例如 widget_p.h。 不再可能在 widget.cpp 文件中声明它。</p>
<h4 id="widget-h-2"><a href="#widget-h-2" class="headerlink" title="widget.h"></a><strong>widget.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// only subclasses may access the below</span></span><br><span class="line">    <span class="comment">// allow subclasses to initialize with their own concrete Private</span></span><br><span class="line">    Widget(WidgetPrivate &amp;d);</span><br><span class="line">    WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-p-h-2"><a href="#widget-p-h-2" class="headerlink" title="widget_p.h"></a><strong>widget_p.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WidgetPrivate(Widget *q) : q_ptr(q) &#123; &#125; <span class="comment">// constructor that initializes the q-ptr</span></span><br><span class="line">    Widget *q_ptr; <span class="comment">// q-ptr that points to the API class</span></span><br><span class="line">    Rect geometry;</span><br><span class="line">    <span class="keyword">String</span> stylesheet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp-2"><a href="#widget-cpp-2" class="headerlink" title="widget.cpp"></a><strong>widget.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget::Widget() : d_ptr(<span class="keyword">new</span> WidgetPrivate(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::Widget(WidgetPrivate &amp;d) : d_ptr(&amp;d)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="label-h-2"><a href="#label-h-2" class="headerlink" title="label.h"></a><strong>label.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Label();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Label(LabelPrivate &amp;d); <span class="comment">// allow Label subclasses to pass on their Private</span></span><br><span class="line">    <span class="comment">// notice how Label does not have a d_ptr! It just uses Widget's d_ptr.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="label-cpp-2"><a href="#label-cpp-2" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget_p.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabelPrivate</span> :</span> <span class="keyword">public</span> WidgetPrivate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::Label()</span><br><span class="line"> : Widget(*<span class="keyword">new</span> LabelPrivate) <span class="comment">// initialize the d-pointer with our own Private</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Label::Label(LabelPrivate &amp;d) : Widget(d)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Do you see the beauty? When we now create a <code>Label</code> object, it will create a <code>LabelPrivate</code> (which subclasses <code>WidgetPrivate</code>). It passes on the concrete <em>d-pointer</em> to Widget’s protected constructor! Now, when a <code>Label</code> object is created, there is only one memory allocation. Label also has a protected constructor that can be used by its subclasses to provide their own private classes.</p>
<p>你看到美了吗？ 当我们现在创建一个 Label 对象时，它将创建一个 LabelPrivate（它是 WidgetPrivate 的子类）。 它将具体的 d 指针传递给 Widget 的受保护构造函数！ 现在，当一个 Label 对象被创建时，只有一个内存分配。 Label 还有一个受保护的构造函数，它的子类可以使用它来提供它们自己的私有类。</p>
<h3 id="d-pointers-in-Qt"><a href="#d-pointers-in-Qt" class="headerlink" title="d-pointers in Qt"></a>d-pointers in Qt</h3><p>In Qt, practically every public class uses the d-pointer approach. The only cases where it’s not used is when it is known in advance that the class will never ever have extra member variables added to it. For example, for classes like <code>QPoint</code>, <code>QRect</code>, no new members are expected to be added and hence the data members are stored straight into the class itself instead of using the d-pointer.</p>
<p>Notice that in Qt, the base class of all Private objects is <code>QObjectPrivate</code>.</p>
<p>在 Qt 中，几乎每个公共类都使用 d 指针方法。 唯一不使用它的情况是事先知道该类永远不会添加额外的成员变量。 例如，对于像 QPoint、QRect 这样的类，不需要添加新成员，因此数据成员直接存储到类本身中，而不是使用 d 指针。</p>
<p>请注意，在 Qt 中，所有 Private 对象的基类都是 QObjectPrivate。</p>
<h3 id="Q-D-and-Q-Q"><a href="#Q-D-and-Q-Q" class="headerlink" title="Q_D and Q_Q"></a>Q_D and Q_Q</h3><p>A side effect of the optimization that we did in the previous step is that the q-ptr and d-ptr are of type <code>Widget</code> and <code>WidgetPrivate</code>. This means that the following won’t work.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::setText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">String</span> &amp;<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// won't work! since d_ptr is of type WidgetPrivate even though</span></span><br><span class="line">   <span class="comment">// it points to LabelPrivate object</span></span><br><span class="line">   d_ptr-&gt;<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hence, when accessing the d-pointer in a subclass, we need to static_cast to the appropriate type.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::setText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">String</span> &amp;<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LabelPrivate *d = <span class="keyword">static_cast</span>&lt;LabelPrivate*&gt;(d_ptr); <span class="comment">// cast to our private type</span></span><br><span class="line">    d-&gt;<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, it’s not pretty having static_cast all over the place. Instead, there are two macros defined in src/corelib/global/qglobal.h which make it straighforward:</p>
<h4 id="global-h"><a href="#global-h" class="headerlink" title="global.h"></a><strong>global.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_D(Class) Class##Private * const d = d_func()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_Q(Class) Class * const q = q_func()</span></span><br></pre></td></tr></table></figure>

<h4 id="label-cpp-3"><a href="#label-cpp-3" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With Q_D you can use the members of LabelPrivate from Label</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::setText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">String</span> &amp;<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_D(Label);</span><br><span class="line">    d-&gt;<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With Q_Q you can use the members of Label from LabelPrivate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LabelPrivate::someHelperFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_Q(Label);</span><br><span class="line">    q-&gt;selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Q-DECLARE-PRIVATE-and-Q-DECLARE-PUBLIC"><a href="#Q-DECLARE-PRIVATE-and-Q-DECLARE-PUBLIC" class="headerlink" title="Q_DECLARE_PRIVATE and Q_DECLARE_PUBLIC"></a>Q_DECLARE_PRIVATE and Q_DECLARE_PUBLIC</h3><p>Qt classes have a <code>Q_DECLARE_PRIVATE</code> macro in the public class. The macro reads:</p>
<h4 id="qglobal-h"><a href="#qglobal-h" class="headerlink" title="qglobal.h"></a><strong>qglobal.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PRIVATE(Class)\</span></span><br><span class="line">    <span class="keyword">inline</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> </span>&#123;\</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr));\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;\</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> Class##Private *&gt;(qGetPtrHelper(d_ptr));\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>##<span class="title">Private</span>;</span></span><br></pre></td></tr></table></figure>

<p>This macro can be used this way:</p>
<h4 id="qlabel-h"><a href="#qlabel-h" class="headerlink" title="qlabel.h"></a><strong>qlabel.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QLabel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Q_DECLARE_PRIVATE(QLabel)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The idea is that <code>QLabel</code> provides a function <code>d_func()</code> that allows access to its private internal class. The method itself is private (since the macro is inside a private section in qlabel.h). The <code>d_func()</code> can however be invoked by <strong>friends</strong> (C++ friend) of <code>QLabel</code>. This is primarily useful for access of information by Qt classes which cannot get access of some <code>QLabel</code> information using public api. As a bizarre example, <code>QLabel</code> might keep track of how many times the user has clicked on a link. However, there is no public API to access this information. <code>QStatistics</code> is a class that needs this information. A Qt developer will add <code>QStatistics</code> as a friend of <code>QLabel</code> and <code>QStatistics</code> can then do <code>label-&gt;d_func()-&gt;linkClickCount</code>.</p>
<p>The <code>d_func</code> also has the advantage to enforce const-correctness: In a const member function of MyClass you need a <code>Q_D(const MyClass)</code> and thus you can only call const member functions in MyClassPrivate. With a <em>naked</em> d_ptr you could also call non-const functions.</p>
<p>这个想法是 QLabel 提供了一个函数 d_func() 允许访问其私有内部类。 该方法本身是私有的（因为宏位于 qlabel.h 的私有部分中）。 然而 d_func() 可以被 QLabel 的朋友（C++ 朋友）调用。 这主要用于通过 Qt 类访问信息，这些类无法使用公共 api 访问某些 QLabel 信息。 作为一个奇怪的例子，QLabel 可能会跟踪用户点击链接的次数。 但是，没有公共 API 可以访问此信息。 QStatistics 是一个需要此信息的类。 Qt 开发人员会将 QStatistics 添加为 QLabel 的朋友，然后 QStatistics 可以执行 label-&gt;d_func()-&gt;linkClickCount。</p>
<p>d_func 还具有强制 const 正确性的优点：在 MyClass 的 const 成员函数中，您需要 Q_D(const MyClass)，因此您只能在 MyClassPrivate 中调用 const 成员函数。 使用裸 d_ptr 您还可以调用非常量函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/20/QThread-general-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/QThread-general-usage/" class="post-title-link" itemprop="url">QThread general usage</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-20 22:20:40 / Modified: 22:35:30" itemprop="dateCreated datePublished" datetime="2022-09-20T22:20:40+08:00">2022-09-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Threads in an operating system are a very simple thing. Write a function, maybe bundle it with some data and push it onto a newly created thread. Use a mutex or other method to safely communicate with the thread if necessary. Whether it are Win32, POSIX or other threads, they all basically work the same and are quite fool-proof.</p>
<p>操作系统中的线程是一件非常简单的事情。 编写一个函数，或许将它与一些数据捆绑在一起并将其推送到一个新创建的线程上。 如有必要，使用互斥锁或其他方法安全地与线程通信。 无论是Win32、POSIX还是其他线程，基本上都是一样的，而且相当的万无一失。</p>
<p>Those who have discovered the joys of the Qt framework may assume that threads in Qt are just like this, and they would be right. However, there are several different ways to use threads in Qt, and it might not be obvious which approach to choose. The article, <a href="http://doc.qt.io/qt-5/threads-technologies.html" target="_blank" rel="noopener">Multithreading Technologies in Qt</a>, compares the different approaches.</p>
<p>那些发现 Qt 框架的乐趣的人可能会认为 Qt 中的线程就是这样，他们是对的。 然而，在 Qt 中使用线程有几种不同的方法，选择哪种方法可能并不明显。 Qt 中的多线程技术一文比较了不同的方法。</p>
<p>The rest of this article demonstrates one of these methods: <strong>QThread + a worker QObject</strong>. This method is intended for use cases which involve event-driven programming and signals + slots across threads.</p>
<p>本文的其余部分演示了其中一种方法：QThread + 一个worker QObject。 此方法适用于涉及事件驱动编程和跨线程信号 + 槽的用例。</p>
<h3 id="Usage-with-Worker-class"><a href="#Usage-with-Worker-class" class="headerlink" title="Usage with Worker class"></a>Usage with Worker class</h3><p>The main thing in this example to keep in mind when using a QThread is that it’s not a thread. It’s a wrapper around a thread object. This wrapper provides the signals, slots and methods to easily use the thread object within a Qt project. To use it, prepare a QObject subclass with all your desired functionality in it. Then create a new QThread instance, push the QObject onto it using moveToThread(QThread*) of the QObject instance and call start() on the QThread instance. That’s all. You set up the proper signal/slot connections to make it quit properly and such, and that’s all.</p>
<p>在这个例子中使用 QThread 时要记住的主要事情是它不是线程。 它是一个线程对象的包装器。 这个包装器提供了信号、槽和方法，以便在 Qt 项目中轻松使用线程对象。 要使用它，请准备一个 QObject 子类，其中包含您想要的所有功能。 然后创建一个新的 QThread 实例，使用 QObject 实例的 moveToThread(QThread*) 将 QObject 推送到其上，并在 QThread 实例上调用 start()。 就这样。 您设置了正确的信号/插槽连接以使其正确退出等等，仅此而已。</p>
<h4 id="Declare-Worker-class"><a href="#Declare-Worker-class" class="headerlink" title="Declare Worker class"></a>Declare Worker class</h4><p>For a basic example, check this class declaration for the Worker class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Worker();</span><br><span class="line">    ~Worker();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(QString err)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// add your variables here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We add at least one public slot which will be used to trigger the instance and make it start processing data once the thread has started. Now, let’s see what the implementation for this basic class looks like.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Worker::Worker() &#123; <span class="comment">// Constructor</span></span><br><span class="line">    <span class="comment">// you could copy data from constructor arguments to internal variables here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Worker::~Worker() &#123; <span class="comment">// Destructor</span></span><br><span class="line">    <span class="comment">// free resources</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker::process</span><span class="params">()</span> </span>&#123; <span class="comment">// Process. Start processing data.</span></span><br><span class="line">    <span class="comment">// allocate resources using new here</span></span><br><span class="line">    qDebug(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="function">emit <span class="title">finished</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While this Worker class doesn’t do anything special, it nevertheless contains all the required elements. It starts processing when its main function, in this case process(), is called and when it is done it emits the signal finished() which will then be used to trigger the shutdown of the QThread instance it is contained in.</p>
<p>虽然这个 Worker 类没有做任何特别的事情，但它仍然包含所有必需的元素。 当它的主函数（在本例中为 process()）被调用时，它开始处理，当它完成时，它发出信号 finished()，然后将用于触发它所在的 QThread 实例的关闭。</p>
<p>By the way, one extremely important thing to note here is that you should NEVER allocate heap objects (using new) in the constructor of the QObject class as this allocation is then performed on the main thread and not on the new QThread instance, meaning that the newly created object is then owned by the main thread and not the QThread instance. This will make your code fail to work. Instead, allocate such resources in the main function slot such as process() in this case as when that is called the object will be on the new thread instance and thus it will own the resource.</p>
<p>顺便说一句，这里要注意的一件非常重要的事情是，您永远不应该在 QObject 类的构造函数中分配堆对象（使用 new），因为这种分配是在主线程上执行的，而不是在新的 QThread 实例上执行的，这意味着 然后，新创建的对象归主线程所有，而不是 QThread 实例。 这将使您的代码无法正常工作。 相反，在这种情况下，在诸如 process() 之类的主函数槽中分配此类资源，因为当调用该对象时，该对象将位于新线程实例上，因此它将拥有该资源。</p>
<h4 id="Create-a-new-Worker-instance"><a href="#Create-a-new-Worker-instance" class="headerlink" title="Create a new Worker instance"></a>Create a new Worker instance</h4><p>Now, let’s see how to use this new construction by creating a new Worker instance and putting it on a QThread instance:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QThread* thread = <span class="keyword">new</span> QThread();</span><br><span class="line">Worker* worker = <span class="keyword">new</span> Worker();</span><br><span class="line">worker-&gt;moveToThread(thread);</span><br><span class="line"><span class="built_in">connect</span>( worker, &amp;Worker::error, <span class="keyword">this</span>, &amp;MyClass::errorString);</span><br><span class="line"><span class="built_in">connect</span>( thread, &amp;QThread::started, worker, &amp;Worker::<span class="built_in">process</span>);</span><br><span class="line"><span class="built_in">connect</span>( worker, &amp;Worker::finished, thread, &amp;QThread::quit);</span><br><span class="line"><span class="built_in">connect</span>( worker, &amp;Worker::finished, worker, &amp;Worker::deleteLater);</span><br><span class="line"><span class="built_in">connect</span>( thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);</span><br><span class="line">thread-&gt;start();</span><br></pre></td></tr></table></figure>

<p>The connect() series here is the most crucial part. The first connect() line hooks up the error message signal from the worker to an error processing function in the main thread. The second connects the thread’s started() signal to the processing() slot in the worker, causing it to start.</p>
<p>这里的connect()系列是最关键的部分。 第一个 connect() 行将来自 worker 的错误消息信号连接到主线程中的错误处理函数。 第二个将线程的 started() 信号连接到 worker 中的 processing() 槽，使其启动。</p>
<p>Then the clean-up: when the worker instance emits finished(), as we did in the example, it will signal the thread to quit, i.e. shut down. We then mark the worker instance using the same finished() signal for deletion. Finally, to prevent nasty crashes because the thread hasn’t fully shut down yet when it is deleted, we connect the finished() of the thread (not the worker!) to its own deleteLater() slot. This will cause the thread to be deleted only after it has fully shut down.</p>
<p>然后进行清理：当worker实例发出finished()时，就像我们在示例中所做的那样，它将发出线程退出的信号，即关闭。 然后，我们使用相同的 finished() 信号标记工作实例以进行删除。 最后，为了防止由于线程在被删除时尚未完全关闭而导致的严重崩溃，我们将线程（不是工作线程！）的finished() 连接到它自己的deleteLater() 槽。 这将导致线程仅在完全关闭后才被删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/17/Hexo%E5%86%99%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/Hexo%E5%86%99%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">超详细Hexo+Github博客搭建小白教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-17 13:56:14" itemprop="dateCreated datePublished" datetime="2022-09-17T13:56:14+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-20 21:37:30" itemprop="dateModified" datetime="2022-09-20T21:37:30+08:00">2022-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文链接:<a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p>
<p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p>
<p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p>
<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>
<p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p>
<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000/">http://localhost:4000/</a>，就可以看到我们的博客啦.</p>
<p>按<code>ctrl+c</code>关闭本地服务器。</p>
<h2 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h2><p>首先右键打开git bash，然后输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"godweiyang"</span></span><br><span class="line">git config --global user.email <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></figure>

<p>用户名和邮箱根据你注册github的信息自行修改。</p>
<p>然后生成密钥SSH key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></figure>

<p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p>
<p>git bash中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>将输出的内容复制到框中，点击确定保存。</p>
<p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p>
<p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p>
<p>修改最后一行的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/godweiyang/godweiyang.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repository修改为你自己的github项目地址。</p>
<h2 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p>
<p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>
<p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>
<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>把下载的主题的文件放在theme目录下，<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/releases</a></p>
<p>修改配置文件主题为当前主题名字。</p>
<p>然后运行<code>hexo clean</code>清空所有生成的网页缓存，<code>hexo g</code>、<code>hexo d</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
