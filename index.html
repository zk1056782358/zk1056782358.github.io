<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/24/Python-QML-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/24/Python-QML-integration/" class="post-title-link" itemprop="url">Python-QML integration</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-24 21:12:07 / Modified: 21:20:16" itemprop="dateCreated datePublished" datetime="2022-09-24T21:12:07+08:00">2022-09-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PySide6/" itemprop="url" rel="index"><span itemprop="name">PySide6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Python-QML-integration"><a href="#Python-QML-integration" class="headerlink" title="Python-QML integration"></a>Python-QML integration</h1><p>This tutorial provides a quick walk-through of a python application that loads, and interacts with a QML file. QML is a declarative language that lets you design UIs faster than a traditional language, such as C++. The QtQml and QtQuick modules provides the necessary infrastructure for QML-based UIs.</p>
<p>In this tutorial, you will learn how to integrate Python with a QML application. This mechanism will help us to understand how to use Python as a backend for certain signals from the UI elements in the QML interface. Additionally, you will learn how to provide a modern look to your QML application using one of the features from Qt Quick Controls 2.</p>
<p>The tutorial is based on an application that allow you to set many text properties, like increasing the font size, changing the color, changing the style, and so on. Before you begin, install the <a href="https://pypi.org/project/PySide6/" target="_blank" rel="noopener">PySide6</a> Python packages.</p>
<p>The following step-by-step process will guide you through the key elements of the QML based application and PySide6 integration:</p>
<p>本篇教程将快速地教大家如何编写一个载入 [QML]文件并与之交互的 python 应用程序。与传统语言（C++ 等）不同，QML是一种描述性语言，它能让你更快地设计 UI 界面。<em>QtQml</em> 和 <em>QtQuick</em> 模块提供了 Python 使用 QML 所需的底层。</p>
<p>在这篇教程里，你将学习怎么通过<strong>上下文属性 (context property)</strong>来结合 Python 和 QML。这个机制会帮助我们理解怎么使用 Python 作为后端，来连接 QML 界面中一些 UI 元素的信号。同时，你还会学到怎么使用 Qt Quick Controls 2 中的特征来为你的 QML 应用程序提供一个更现代的外观。</p>
<p>你可以在里面更改各种文本属性，比如增加字体大小、修改颜色、修改样式等等。接下来教程将一步步教你怎么修改 QML/PySide6 混合的程序中几个关键组件的样式。</p>
<p>1.首先我们从这个基于 QML 的 UI 界面开始：</p>
<p>界面布局使用了 <em>GridLayout<em>，其中又包含了两个 *ColumnLayout</em>。在界面里有好几个 *RadioButton</em> 和 <em>Button</em> 组件，还有一个 <em>Slider</em> 组件。</p>
<p>2.将这个 QML 文件放在根目录下，你可以通过 Python 来载入它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instance of the Python object</span></span><br><span class="line">bridge = Bridge()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expose the Python object to QML</span></span><br><span class="line">context = engine.rootContext()</span><br><span class="line">context.setContextProperty(<span class="string">"con"</span>, bridge)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the path of the current directory, and then add the name</span></span><br><span class="line"><span class="comment"># of the QML file, to load it.</span></span><br><span class="line">qmlFile = Path(__file__).parent / <span class="string">'view.qml'</span></span><br></pre></td></tr></table></figure>

<p>需要注意到，我们将上下文属性命名为 <strong>con</strong>，并载入了指定的 QML 文件。</p>
<p>3.定义 <em>Bridge</em> 类，其中包含了上下文属性的所有逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To be used on the @QmlElement decorator</span></span><br><span class="line"><span class="comment"># (QML_IMPORT_MINOR_VERSION is optional)</span></span><br><span class="line">QML_IMPORT_NAME = <span class="string">"io.qt.textproperties"</span></span><br><span class="line">QML_IMPORT_MAJOR_VERSION = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@QmlElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bridge</span><span class="params">(QObject)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Slot(str, result=str)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getColor</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s.lower() == <span class="string">"red"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#ef9a9a"</span></span><br><span class="line">        <span class="keyword">elif</span> s.lower() == <span class="string">"green"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#a5d6a7"</span></span><br><span class="line">        <span class="keyword">elif</span> s.lower() == <span class="string">"blue"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#90caf9"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"white"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Slot(float, result=int)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSize</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        size = int(s * <span class="number">34</span>)</span><br><span class="line">        <span class="keyword">if</span> size &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> size</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Slot(str, result=bool)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getItalic</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s.lower() == <span class="string">"italic"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Slot(str, result=bool)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getBold</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s.lower() == <span class="string">"bold"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/24/Your-First-QtQuick-QML-Application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/24/Your-First-QtQuick-QML-Application/" class="post-title-link" itemprop="url">Your First QtQuick/QML Application</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-24 20:39:29 / Modified: 21:12:47" itemprop="dateCreated datePublished" datetime="2022-09-24T20:39:29+08:00">2022-09-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PySide6/" itemprop="url" rel="index"><span itemprop="name">PySide6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://doc.qt.io/qt-6/qmlapplications.html" target="_blank" rel="noopener">QML</a> is a declarative language that lets you develop applications faster than with traditional languages. It is ideal for designing the UI of your application because of its declarative nature. In QML, a user interface is specified as a tree of objects with properties. In this tutorial, we will show how to make a simple “Hello World” application with PySide6 and QML.</p>
<p>QML 是一种声明性语言，可让您比使用传统语言更快地开发应用程序。 由于其声明性，它非常适合设计应用程序的 UI。 在 QML 中，用户界面被指定为具有属性的对象树。 在本教程中，我们将展示如何使用 PySide6 和 QML 制作一个简单的“Hello World”应用程序。</p>
<p>A PySide6/QML application consists, at least, of two different files - a file with the QML description of the user interface, and a python file that loads the QML file. To make things easier, let’s save both files in the same directory.</p>
<p>PySide6/QML 应用程序至少包含两个不同的文件——一个包含用户界面 QML 描述的文件，以及一个加载 QML 文件的 python 文件。 为了方便起见，让我们将这两个文件保存在同一个目录中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick</span><br><span class="line"></span><br><span class="line">Rectangle &#123;</span><br><span class="line">    id: main</span><br><span class="line">    width: <span class="number">200</span></span><br><span class="line">    height: <span class="number">200</span></span><br><span class="line">    color: <span class="string">"green"</span></span><br><span class="line"></span><br><span class="line">    Text &#123;</span><br><span class="line">        text: <span class="string">"Hello World"</span></span><br><span class="line">        anchors.centerIn: main</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We start by importing <code>QtQuick</code>, which is a QML module.</p>
<p>The rest of the QML code is pretty straightforward for those who have previously used HTML or XML files. Basically, we are creating a green rectangle with the size 200*200, and adding a Text element that reads “Hello World”. The code <code>anchors.centerIn: main</code> makes the text appear centered within the object with <code>id: main</code>, which is the Rectangle in this case.</p>
<p>对于以前使用过 HTML 或 XML 文件的人来说，其余的 QML 代码非常简单。 基本上，我们正在创建一个大小为 200*200 的绿色矩形，并添加一个文本元素，内容为“Hello World”。 代码 anchors.centerIn:main 使文本在 id:main 的对象中居中显示，在本例中为 Rectangle。</p>
<p>Now, let’s see how the code looks on the PySide6. Let’s call it <code>main.py</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PySide6.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"><span class="keyword">from</span> PySide6.QtQuick <span class="keyword">import</span> QQuickView</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    app = QApplication()</span><br><span class="line">    view = QQuickView()</span><br><span class="line"></span><br><span class="line">    view.setSource(<span class="string">"view.qml"</span>)</span><br><span class="line">    view.show()</span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>

<p>If you are already familiar with PySide6 and have followed our tutorials, you have already seen much of this code. The only novelties are that you must <code>import QtQuick</code> and set the source of the <code>QQuickView</code> object to the URL of your QML file. Then, similar to what you do with any Qt widget, you call <code>QQuickView.show()</code>.</p>
<p>如果您已经熟悉 PySide6 并按照我们的教程进行操作，那么您已经看过大部分代码。 唯一的新奇之处在于您必须导入 QtQuick 并将 QQuickView 对象的源设置为您的 QML 文件的 URL。 然后，与您对任何 Qt 小部件所做的类似，您调用 QQuickView.show()。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/24/Qt-for-Python-Quick-Start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/24/Qt-for-Python-Quick-Start/" class="post-title-link" itemprop="url">Qt for Python Quick Start</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-24 20:16:24 / Modified: 21:12:57" itemprop="dateCreated datePublished" datetime="2022-09-24T20:16:24+08:00">2022-09-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PySide6/" itemprop="url" rel="index"><span itemprop="name">PySide6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><p>Before you can install Qt for Python, first you must install the following software:</p>
<blockquote>
<ul>
<li>Python 3.6+,</li>
<li>We recommend using a virtual environment, such as <a href="https://docs.python.org/3/library/venv.html" target="_blank" rel="noopener">venv</a> or <a href="https://virtualenv.pypa.io/en/latest" target="_blank" rel="noopener">virtualenv</a></li>
</ul>
</blockquote>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul>
<li><p><strong>Creating and activating an environment</strong> You can do this by running the following on a terminal:</p>
<ul>
<li><strong>python -m venv env</strong>, (Your Python executable might be called <code>python3</code>)</li>
<li><strong>source env/bin/activate</strong> for Linux and macOS</li>
<li><strong>env\Scripts\activate.bat</strong> for Windows</li>
</ul>
</li>
<li><p><strong>Installation</strong></p>
<p>Now you are ready to install the Qt for Python packages using <code>pip</code>. From the terminal, run the following command:</p>
<ul>
<li><strong>pip install pyside6</strong>, for the latest version.</li>
<li><strong>pip install pyside6==6.0</strong>, for the version <code>6.0</code> specifically.</li>
<li>It is also possible to install a specific snapshot from our servers. To do so, you can use the following command:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --index-url=https:<span class="comment">//download.qt.io/snapshots/ci/pyside/6.0.0/latest pyside6 --trusted-host download.qt.io</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Test your installation</strong></p>
<p>Now that you have Qt for Python installed, test your setup by running the following Python constructs to print version information:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySide6.QtCore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prints PySide6 version</span></span><br><span class="line">print(PySide6.__version__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prints the Qt version used to compile PySide6</span></span><br><span class="line">print(PySide6.QtCore.__version__)</span><br></pre></td></tr></table></figure>

<h2 id="Create-a-Simple-Application"><a href="#Create-a-Simple-Application" class="headerlink" title="Create a Simple Application"></a>Create a Simple Application</h2><p>Your Qt for Python setup is ready. You can explore it further by developing a simple application that prints “Hello World” in several languages. The following instructions will guide you through the development process:</p>
<p><strong>Imports</strong></p>
<p>Create a new file named <code>hello_world.py</code>, and add the following imports to it.:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PySide6 <span class="keyword">import</span> QtCore,QtWidgets,QtGui</span><br></pre></td></tr></table></figure>

<p>The PySide6 Python module provides access to the Qt APIs as its submodule. In this case, you are importing the <code>QtCore</code>, <code>QtWidgets</code>, and <code>QtGui</code> submodules.</p>
<p><strong>Main Class</strong></p>
<p>Define a class named <code>MyWidget</code>, which extends QWidget and includes a QPushButton and QLabel.:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PySide6 <span class="keyword">import</span> QtCore,QtWidgets,QtGui</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span><span class="params">(QtWidgets.QWidget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.hello = [<span class="string">"Hallo"</span>,<span class="string">"Hei"</span>,<span class="string">"Hola"</span>,<span class="string">"zzz"</span>]</span><br><span class="line"></span><br><span class="line">        self.button = QtWidgets.QPushButton(<span class="string">"click me"</span>)</span><br><span class="line">        self.text = QtWidgets.QLabel(<span class="string">"Hello World"</span>,alignment=QtCore.Qt.AlignCenter)</span><br><span class="line">        self.layout = QtWidgets.QVBoxLayout(self)</span><br><span class="line">        self.layout.addWidget(self.text)</span><br><span class="line">        self.layout.addWidget(self.button)</span><br><span class="line"></span><br><span class="line">        self.button.clicked.connect(self.magic)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @QtCore.Slot()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magic</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.text.setText(random.choice(self.hello))</span><br></pre></td></tr></table></figure>

<p>The MyWidget class has the <code>magic</code> member function that randomly chooses an item from the <code>hello</code> list. When you click the button, the <code>magic</code> function is called.</p>
<p><strong>Application execution</strong></p>
<p>Now, add a main function where you instantiate <code>MyWidget</code> and <code>show</code> it.:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = QtWidgets.QApplication([])</span><br><span class="line"></span><br><span class="line">    widget = MyWidget()</span><br><span class="line">    widget.resize(<span class="number">800</span>,<span class="number">600</span>)</span><br><span class="line">    widget.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec())</span><br></pre></td></tr></table></figure>

<p>Run your example by writing the following command: <strong>python hello_world.py</strong>.</p>
<p>Try clicking the button at the bottom to see which greeting you get.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/24/VSCode-PySide6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/24/VSCode-PySide6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">VSCode+PySide6开发环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-24 20:07:27 / Modified: 20:13:02" itemprop="dateCreated datePublished" datetime="2022-09-24T20:07:27+08:00">2022-09-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PyQt/" itemprop="url" rel="index"><span itemprop="name">PyQt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Python-GUI框架"><a href="#Python-GUI框架" class="headerlink" title="Python GUI框架"></a>Python GUI框架</h2><p>作为Python开发者，你迟早都会用到图形用户界面来开发应用。常用的GUI框架有Tkinter、PyQT、wxPython、PySide、Kivy等等，各有优缺点。其中PyQt和PySide都是基于QT designer模块，将ui界面翻译为python程序，底层都是调用QT的ui界面库，使用起来基本没有区别。</p>
<p>PyQT的开发商是Riverbank Computing，采用的是GPLv3许可证和需要购买版权的商业许可证发布的，该许可证允许开发专有应用程序，可以由开发者选择。GPLv3许可证大概意思就是说，使用PyQt后你的程序就必须要开源，如果闭源商用就会违反协议，后果自负。</p>
<p>PySide的开发商是NOKIA/The Qt Company（也即PySide是QT的亲儿子），采用LGPL协议。LGPL协议是一个商业友好的协议使用 LGPL 协议开发闭源程序，如果你使用动态链接的形式，那么，你可以以任何形式（商业的、非商业的、开源的、非开源的等等）发布你的应用程序。</p>
<p>PyQT/PySide采用鼠标拖拉的方式直接设计界面，简单快捷，而且可以使用QT强大的底层库，因此是界面设计的首选，但是考虑二者的商业特性以及官方维护，使用PySide作为GUI框架。</p>
<p><strong>PySide6介绍</strong></p>
<p>QT官方发布Qt6.0之后，紧接着于2020年12月10日发布了PySide 6，对应C++版的Qt6。从PySide6开始，PySide的命名也会与Qt的大版本号保持一致。需要注意的是使用PySide6开发的程序在默认情况下，不兼容Windows7系统，这也是Qt6所决定的。</p>
<p>PySide为我们提供了两种开发界面的方式，一种叫QtWidget，是在网上搜到的教程中最常见的方式；另一种叫QML，是一种新型的开发方式，也是Qt正在努力推广的开发方式。在本系列的文章中，我们主要使用QtWidget这种方式，而使用QtWidget开发程序时，也有两种基本的使用方法，一种是通过designer开发界面，另一种是用过代码手动开发界面，这里我们的目的是极简快速入门，所以使用designer这种方便的方式进行开发。</p>
<h2 id="PySide6安装"><a href="#PySide6安装" class="headerlink" title="PySide6安装"></a><strong>PySide6安装</strong></h2><p>在command中或者vscode的terminal中运行pip命令，采用国内源安装速度较快。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 包名-i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>

<p>–trusted-host pypi.douban.com 这是为了获得ssl证书的认证</p>
<h2 id="PyQt扩展安装"><a href="#PyQt扩展安装" class="headerlink" title="PyQt扩展安装"></a>PyQt扩展安装</h2><p>打开VSCode左侧边栏的Extension，搜索pyside或者Qt for Python，点击Install。</p>
<h2 id="PyQt工具简介"><a href="#PyQt工具简介" class="headerlink" title="PyQt工具简介"></a>PyQt工具简介</h2><p>Qt/PyQt中包括一系列的工具，其中：</p>
<ul>
<li>Qt Designer: 用即见即所得的方式设计图形界面，成果表现为扩展名为ui的文件。 可执行文件：designer 。</li>
<li>UI Compiler: 将上述ui文件“编译”成Python程序。执行该Python程序便可以得ui文件所描述的图形界面。可执行文件: pyuic5。</li>
<li>Qt Linguist: 语言学家，可以便捷的实现软件的国际化，即生成软件的法语、英语、日语或者其它语种版本。工作模式大致可以描述成：先用pylupdate5扫描源代码中全部可翻译的字符串，然后用linguist翻译相应的字符串至目标语言，接下来用lrelease工具发布。软件运行时，加载法语版本的语言学家文件，软件界面就是法语，加载日语版本的语言学家文件，软件界面就是日语。可执行文件：linguist,pylupdate5,lrelease。</li>
<li>Resource Compiler: 资源编译器。UI文件设计过程中可以需要使用到各种图片，这些图片以资源文件的形式组织，扩展名为qrc；资源编译器负责将 qrc格式的资源文件编译成py文件，其中，图片被转换成bytes字节流。可执行文件： pyrcc5。</li>
</ul>
<h2 id="PyQt扩展的配置"><a href="#PyQt扩展的配置" class="headerlink" title="PyQt扩展的配置"></a>PyQt扩展的配置</h2><p>在Visual Studio Code中的Extensions管理页面，点击Qt for Python扩展的Manage齿轮按钮，</p>
<p>然后，按照提示逐一设置各种可执行文件/模块的路径及运行参数信息。</p>
<h2 id="创建新的UI文件"><a href="#创建新的UI文件" class="headerlink" title="创建新的UI文件"></a>创建新的UI文件</h2><p>在Visual Studio Code项目目录的空白位置右击鼠标，选择New Form(Qt Designer UI File)</p>
<h2 id="打开已有的UI文件"><a href="#打开已有的UI文件" class="headerlink" title="打开已有的UI文件"></a>打开已有的UI文件</h2><p>在Visual Studio Code项目目录中单击打开UI文件（比如下图中的MainWidget.ui)，然后右击鼠标，在弹出菜单中选择Edit Form(Qt Designer UI File)。</p>
<h2 id="资源文件的编译"><a href="#资源文件的编译" class="headerlink" title="资源文件的编译"></a>资源文件的编译</h2><p>在Visual Studio Code中打开资源文件，如Images.qrc， 然后在编辑框中右击鼠标，并在弹出菜单中选择 Compile Resource File into Qt for Python File。</p>
<p>资源文件编译后，生成Images_rc.py文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/24/Threads-Events-QObjects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/24/Threads-Events-QObjects/" class="post-title-link" itemprop="url">Threads Events QObjects</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-24 12:54:42 / Modified: 17:50:30" itemprop="dateCreated datePublished" datetime="2022-09-24T12:54:42+08:00">2022-09-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/QT/" itemprop="url" rel="index"><span itemprop="name">QT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Nine times out of ten, a quick inspection of their code shows that the biggest problem is the very fact they’re using threads in the first place, and they’re falling in one of the endless pitfalls of parallel programming.</p>
<p>The ease of creating and running threads in Qt, combined with some lack of knowledge about programming styles (especially asynchronous network programming, combined with Qt’s signals and slots architecture) and/or habits developed when using other tookits or languages, usually leads to people shooting themselves in the foot. Moreover, threading support in Qt is a double-edged sword: while it makes it very simple for you to do multithread programming, it adds a certain number of features (especially when it comes to interaction with QObjects) you must be aware of.</p>
<p>The purpose of this document is <strong>not</strong> to teach you how to use threads, do proper locking, exploit parallelism, nor write scalable programs; there are many good books about these topics; for instance, take a look to the recommended reading list <a href="http://doc.qt.io/qt-4.8/threads.html" target="_blank" rel="noopener">on this page</a>. Instead, this small article is meant to be a guide to introduce users to threading in Qt 4, in order to avoid the most common pitfalls and help them to develop code that is at the same time more robust and with a better structure.</p>
<p>快速检阅一下他们的代码，在发现的问题当中，十之八九遇到得最大问题是他们在某个地方使用了线程，而随后又坠入了并行编程的陷阱。Qt中创建、运行线程的”易用”性、缺乏相关编程尤其是异步网络编程知识或是养成的使用其它工具集的习惯、这些因素和Qt的信号槽架构混合在一起，便经常使得人们自己把自己射倒在了脚下。此外，Qt对线程的支持是把双刃剑：它即使得你在进行Qt多线程编程时感觉十分简单，但同时你又必须对Qt所新添加许多的特性尤为小心，特别是与QObject的交互。</p>
<p>本文的目的不是教你如何使用线程、如何适当地加锁，也不是教你如何进行并行开发或是如何写可扩展的程序；关于这些话题，有很多好书，比如这个链接给的推荐读物清单. 这篇文章主要是为了向读者介绍Qt 4的事件循环以及线程使用，其目的在于帮助读者们开发出拥有更好结构的、更加健壮的多线程代码，并回避Qt事件循环以及线程使用的常见错误。</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>Not being a general-purpose introduction to (threads) programming, we expect you to have some previous knowledge about:</p>
<ul>
<li>C++ basics (though most suggestions do apply to other languages as well);</li>
<li>Qt basics: QObjects, signals and slots, event handling;</li>
<li>what a thread is and what the relationships are between threads, processes and the operating system;</li>
<li>how to start and stop a thread, and wait for it to finish, under (at least) one major operating system;</li>
<li>how to use mutexes, semaphores and wait conditions to create thread-safe/reentrant functions, data structures, classes.</li>
</ul>
<p>In this document we’ll follow the Qt <a href="http://doc.qt.io/qt-4.8/threads-reentrancy.html" target="_blank" rel="noopener">naming conventions</a>, which are:</p>
<ul>
<li><strong>Reentrant</strong> A class is reentrant if it’s safe to use its instances from more than one thread, provided that at most one thread is accessing the same instance at the same time. A function is reentrant if it’s safe to invoke it from more than one thread at the same, provided that each invocation references unique data. In other words, this means that users of that class/function must <em>serialize</em> all accesses to instances/shared data by means of some <em>external locking mechanism</em>.</li>
<li><strong>Thread-safe</strong> A class is thread-safe if it’s safe to use its instances from more than one thread at the same time. A function is thread-safe if it’s safe to invoke it from more than one thread at the same time even if the invocations reference shared data.</li>
</ul>
<p>考虑到本文并不是一个线程编程的泛泛介绍，我们希望你有如下相关知识：</p>
<ul>
<li>C++基础</li>
<li>Qt基础:QObject,信号/槽,事件处理.</li>
<li>了解线程是什么，线程与进程间的关系和操作系统</li>
<li>了解如何启动和暂停一个线程，如何等待并结束一个线程</li>
<li>了解如何使用mutexes,semaphores以及wait condtions来创建一个线程安全/可重入的函数，数据结构，类</li>
</ul>
<p>本文我们遵循如下Qt名词解释:</p>
<ul>
<li><strong>可重入</strong> 一个类被称为是可重入的：只要在同一时刻至多只有一个线程访问同一个实例，那么我们说多个线程可以安全地使用各自线程内自己的实例。 一个函数被称为是可重入的：如果每一次函数的调用只访问其独有的数据（译者注：全局变量就不是独有的，而是共享的），那么我们说多个线程可以安全地调用这个函数。 也就是说，类和函数的使用者必须通过一些外部的加锁机制来实现访问对象实例或共享数据的序列化。</li>
<li><strong>线程安全</strong> 如果多个线程可以同时使用一个类的对象，那么这个类被称为是线程安全的；如果多个线程可以同时使用一个函数体里的共享数据，那么这个函数被称为线程安全的。 (译者注： 更多可重入(reentrant)和t线程安全(thread-safe)的解释： 对于类，如果它的所有成员函数都可以被不同线程同时调用而不相互影响——即使这些调用是针对同一个类对象，那么该类被定义为线程安全。 对于类，如果其不同实例可以在不同线程中被同时使用而不相互影响，那么该类被定义为可重入。在Qt的定义中，在类这个层次，thread-safe是比reentrant更严格的要求)</li>
</ul>
<h1 id="Events-and-the-event-loop"><a href="#Events-and-the-event-loop" class="headerlink" title="Events and the event loop"></a>Events and the event loop</h1><p>Being an event-driven toolkit, events and event delivery play a central role in Qt architecture. In this article we’ll not give a comprehensive coverage about this topic; we’ll instead focus on some thread-related key concepts (see <a href="http://doc.qt.io/qt-4.8/eventsandfilters.html" target="_blank" rel="noopener">here</a> and <a href="https://doc.qt.io/archives/qq/qq11-events.html" target="_blank" rel="noopener">here</a> for more information about the Qt event system).</p>
<p>An <strong>event</strong> in Qt is an object which represents something interesting that happened; the main difference between an event and a signal is that events are <em>targeted</em> to a specific object in our application (which decides what to do with that event), while signals are emitted “in the wild”. From a code point of view, all events are instances of some subclass of <a href="http://doc.qt.io/qt-4.8/qevent.html" target="_blank" rel="noopener">QEvent</a>, and all QObject-derived classes can override the QObject::event() virtual method in order to handle events targeted to their instances.</p>
<p>Events can be generated from both inside and outside the application; for instance:</p>
<ul>
<li>QKeyEvent and QMouseEvent objects represent some kind of keyboard and mouse interaction, and they come from the window manager;</li>
<li>QTimerEvent objects are sent to a QObject when one of its timers fires, and they (usually) come from the operating system;</li>
<li>QChildEvent objects are sent to a QObject when a child is added or removed, and they come from inside your Qt application.</li>
</ul>
<p>Qt作为一个事件驱动的工具集，其事件和事件派发起到了核心的作用。本文将不会全面的讨论这个话题，而是会聚焦于与线程相关的一些关键概念。</p>
<p>一个Qt的事件是代表了某件另人感兴趣并已经发生的对象；事件与信号的主要区别在于，事件是针对于与我们应用中一个具体目标对象（而这个对象决定了我们如何处理这个事件），而信号发射则是”漫无目的”。从代码的角度来说，所有的事件实例是QEvent的子类，并且所有的QObject的派生类可以重载虚函数QObject::event(),从而实现对目标对象实例事件的处理。</p>
<p>事件可以产生于应用程序的内部，也可以来源于外部；比如：</p>
<ul>
<li>QKeyEvent和QMouseEvent对象代表了与键盘、鼠标相关的交互事件，它们来自于视窗管理程序。 </li>
<li>当计时器开始计时，QTimerEvent 对象被发送到QObject对象中，它们往往来自于操作系统。</li>
<li>当一个子类对象被添加或删除时，QChildEvent对象会被发送到一个QObject对象中，而它们来自于你的应用程序内部</li>
</ul>
<p>The important thing about events is that they’re not delivered as soon as they’re generated; they’re instead queued up in an <strong>event queue</strong> and sent sometime later. The dispatcher itself loops around the event queue and sends queued events to their target objects, and therefore it is called the <strong>event loop</strong>. Conceptually, this is how an event loop looks (see the Qt Quarterly article linked above):</p>
<p>对于事件来讲，一个重要的事情在于它们并没有在事件产生时被立即派发，而是列入到一个事件队列（Event queue）中，等待以后的某一个时刻发送。分配器（dispatcher ）会遍历事件队列，并且将入栈的事件发送到它们的目标对象当中，因此它们被称为事件循环（Event loop）. 从概念上讲,下段代码描述了一个事件循环的轮廓:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (is_active)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!event_queue_is_empty)</span><br><span class="line">		dispatch_next_event();</span><br><span class="line">	wait_for_more_events(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We enter Qt’s main event loop by running QCoreApplication::exec(); this call blocks until QCoreApplication::exit() or QCoreApplication::quit() are called, terminating the loop.</p>
<p>The “wait_for_more_events()” function blocks (that is, it’s not a busy wait) until some event is generated. If we think about it, all that can generate events at that point is some <em>external</em> source (dispatching for all internal events is now complete and there were no more pending events in the event queue to delivery). Therefore, the event loop can be woken up by:</p>
<ul>
<li>window manager activity (key/mouse presses, interaction with the windows, etc.);</li>
<li>sockets activity (there’s some data available to read, or a socket is writable without blocking, there’s a new incoming connection, etc.);</li>
<li>timers (i.e. a timer fired);</li>
<li>events posted from other threads (see later).</li>
</ul>
<p>In a UNIX-like system, window manager activity (i.e. X11) is notified to applications via sockets (Unix Domain or TCP/IP), since clients use them to communicate with the X server. If we decide to implement cross-thread event posting with an internal socketpair(2), all that is left is being woken up by activity on:</p>
<ul>
<li>sockets;</li>
<li>timers;</li>
</ul>
<p>which is exactly what the <strong>select(2)</strong> system call does: it watches over a set of descriptors for activity <em>and</em> it times out (with a configurable timeout) if there’s no activity for a certain while. All Qt needs to do is converting what select returns into an object of the right QEvent subclass and queue it up in the event queue. Now you know what’s inside an event loop :)</p>
<p>我们是通过运行QCoreApplication::exec()来进入Qt的主体事件循环的；这会引发阻塞，直至QCoreApplication::exit() 或者 QCoreApplication::quit() 被调用，进而结束循环。</p>
<p>这个”wait_for_more_events()” 函数产生阻塞，直至某个事件的产生。 如果我们仔细想想，会发现所有在那个时间点产生事件的实体必定是来自于外部的资源（因为当前所有内部事件派发已经结束，事件队列里也没有悬而未决的事件等待处理），因此事件循环被这样唤醒：</p>
<ul>
<li>视窗管理活动（键盘按键、鼠标点击，与视窗的交互等等）；</li>
<li>socket活动 （有可见的用来读取的数据或者一个可写的非阻塞Socket, 一个新的Socket连接的产生）；</li>
<li>timers (即计时器开始计时）</li>
<li>其它线程Post的事件（见后文）。</li>
</ul>
<p>Unix系统中，视窗管理活动（即X11）通过Socket（Unix 域或者TCP/IP）通知应用程序（事件的产生），因为客户端使用它们与X服务器进行通讯。 如果我们决定用一个内部的socketpair(2)来实现跨线程的事件派发，那么视窗管理活动需要唤醒的是</p>
<ul>
<li>sockets</li>
<li>timers</li>
</ul>
<p>这也是<em>select(2)</em> 系统调用所做的： 它为视窗管理活动监控了一组描述符，如果一段时间内没有任何活动，它会超时。Qt所要做的是把系统调用select的返回值转换为正确的QEvent子类对象，并将其列入事件队列的栈中，现在你知道事件循环里面装着什么东西了吧:)</p>
<h2 id="What-requires-a-running-event-loop"><a href="#What-requires-a-running-event-loop" class="headerlink" title="What requires a running event loop?"></a>What requires a running event loop?</h2><p>This isn’t an exhaustive list, but if you have the overall picture, you should be able to guess which classes require a running event loop.</p>
<ul>
<li><strong>Widgets painting and interaction</strong>: QWidget::paintEvent() will be called when delivering QPaintEvent objects, which are generated both by calling QWidget::update() (i.e. internally) or by the window manager (for instance, because a hidden window was shown). The same thing holds for all kinds of interaction (keyboard, mouse, etc.): the corresponding events will require an event loop to be dispatched.</li>
<li><strong>Timers</strong>: long story short, they’re fired when select(2) or similar calls time out, therefore you need to let Qt do those calls for you by returning to the event loop.</li>
<li><strong>Networking</strong>: all low-level Qt networking classes (QTcpSocket, QUdpSocket, QTcpServer, etc.) are asynchronous by design. When you call read(), they just return already available data; when you call write(), they schedule the writing for later. It’s only when you return to the event loop the actual reading/writing takes place. Notice that they do offer synchronous methods (the waitFor* family of methods), but their use is discouraged because they block the event loop while waiting. High-level classes, like QNetworkAccessManager, simply do not offer any synchronous API and require an event loop.</li>
</ul>
<p>下面的清单并不全，但你会有一幅全景图，你应该能够猜到哪些类需要使用事件循环。</p>
<ul>
<li><strong>Widgets 绘图与交互</strong></li>
<li><strong>Timers</strong> </li>
<li><strong>Networking</strong>  所有底层的Qt网络类(QTcpSocket, QUdpSocket, QTcpServer等)均被设计成异步的。当你调用read()时，它们仅仅是返回已经可见的数据而已；当你调用write()时，它们仅是将写操作列入执行计划表待稍后执行。真正的读写仅发生于事件循环返回的时候。请注意虽然Qt网络类提供了相应的同步方法（waitFor* 一族），但它们是不被推荐使用的，原因在于他们阻塞了正在等待的事件循环。像QNetworkAccessManager这样的上层类，并不提供同步API而且需要一个时间循环来实现.</li>
</ul>
<h2 id="Blocking-the-event-loop"><a href="#Blocking-the-event-loop" class="headerlink" title="Blocking the event loop"></a>Blocking the event loop</h2><p>Before discussing why <strong>you should never ever block the event loop</strong>, let’s try to figure out what this “blocking” means. Suppose you have a Button widget which emits a signal when clicked; connected to this signal there’s a slot of our Worker object, which does a lot of work. After you click the button, the stack trace will look like this (the stack grows downwards):</p>
<p>在讨论为什么<em>你永远都不要阻塞事件循环</em>之前，让我们尝试着再进一步弄明白到底”阻塞”意味着什么。假定你有一个按钮widget，它被按下时会emit一个信号；还有一个我们下面定义的Worker对象连接了这个信号，而且这个对象的槽做了很多耗时的事情。当你点击完这个按钮后，从上之下的函数调用栈如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> main(<span class="keyword">int</span>, <span class="keyword">char</span> **)**</span><br><span class="line"><span class="number">2.</span> QApplication::exec()</span><br><span class="line"><span class="number">3.</span> […]</span><br><span class="line"><span class="number">4.</span> QWidget::event(QEvent **)**</span><br><span class="line"><span class="number">5.</span> Button::mousePressEvent(QMouseEvent**)**</span><br><span class="line"><span class="number">6.</span> Button::clicked()</span><br><span class="line"><span class="number">7.</span> […]</span><br><span class="line"><span class="number">8.</span> Worker::doWork()</span><br></pre></td></tr></table></figure>

<p>In main() we started the event loop, as usual, by calling QApplication::exec() (line 2). The window manager sent us the mouse click, which was picked up by the Qt kernel, converted in a QMouseEvent and sent to our widget’s event() method (line 4) by QApplication::notify() (not shown here). Since Button didn’t override event(), the base class implementation (QWidget) is called. QWidget::event() detects the event is actually a mouse click and calls the specialized event handler, that is, Button::mousePressEvent() (line 5). We overrode this method to emit the Button::clicked() signal (line 6), which invokes the Worker::doWork slot of our worker object (line 7).</p>
<p>While the worker is busy working, what’s the event loop doing? You should’ve guessed it: nothing! It dispatched the mouse press event and it’s blocked waiting for the event handler to return. We managed to <strong>block the event loop</strong>, which means that no event is sent any more, until we return from the doWork() slot, up the stack, to the event loop, and let it process pending events.</p>
<p>With the event delivery stuck, <strong>widgets won’t update themselves</strong> (QPaintEvent objects will sit in the queue), <strong>no further interaction with widgets is possible</strong> (for the same reason), <strong>timers won’t fire</strong> and <strong>networking communications will slow down and stop</strong>. Moreover, many window managers will detect that your application is not handling events any more and <strong>tell the user that your application isn’t responding</strong>. That’s why is so important to quickly react to events and return to the event loop as soon as possible!</p>
<p>在main()中，我们通过调用QApplication::exec() （如上段代码第2行所示）开启了事件循环。视窗管理者发送了鼠标点击事件，该事件被Qt内核捕获，并转换成QMouseEvent ，随后通过QApplication::notify() （notify并没有在上述代码里显示）发送到我们的widget的event()方法中（第4行）。因为Button并没有重载event()，它的基类QWidget方法得以调用。 QWidget::event() 检测出传入的事件是一个鼠标点击，并调用其专有的事件处理器，即Button::mousePressEvent() (第5行)。我们重载了 mousePressEvent方法，并发射了Button::clicked()信号（第6行），该信号激活了我们worker对象中十分耗时的Worker::doWork()槽（第8行）。</p>
<p>当worker对象在繁忙的工作时，事件循环在做什么呢？ 你也许猜到了答案：什么也没做！它分发了鼠标点击事件，并且因等待event handler返回而被阻塞。我们阻塞了事件循环，也就是说，在我们的doWork()槽（第8行）干完活之前再不会有事件被派发了，也再不会有pending的事件被处理。</p>
<p>当事件派发被就此卡住时，widgets 也将不会再刷新自己（QPaintEvent对象将在事件队列里静候），也不能有进一步地与widgets交互的事件发生，计时器也不会在开始计时，网络通讯也将变得迟钝、停滞。更严重的是，许多视窗管理程序会检测到你的应用不再处理事件，从而告诉用户你的程序不再有响应（not responding）. 这就是为什么快速的响应事件并尽可能快的返回事件循环如此重要的原因</p>
<h2 id="Forcing-event-dispatching"><a href="#Forcing-event-dispatching" class="headerlink" title="Forcing event dispatching"></a>Forcing event dispatching</h2><p>So, what do we do if we have a long task to run and don’t want to block the event loop? One possible answer is to move the task into another thread: in the next sections we’ll see how to do that. We also have the option to manually force the event loop to run, by (repeatedly) calling QCoreApplication::processEvents() inside our blocking task. QCoreApplication::processEvents() will process all the events in the event queue and return to the caller.</p>
<p>Another available option we can use to forcibly reenter the event loop is the <a href="http://doc.qt.io/qt-4.8/qeventloop.html" target="_blank" rel="noopener">QEventLoop</a> class. By calling QEventLoop::exec() we reenter the event loop, and we can connect signals to the QEventLoop::quit() slot to make it quit. For instance:</p>
<p>那么，对于需要长时间运行的任务，我们应该怎么做才会不阻塞事件循环？ 一个可行的答案是将这个任务移动另一个线程中：在一节，我们会看到如果去做。一个可能的方案是，在我们的受阻塞的任务中，通过调用QCoreApplication::processEvents() 人工地强迫事件循环运行。QCoreApplication::processEvents() 将处理所有事件队列中的事件并返回给调用者。</p>
<p>另一个可选的强制地重入事件的方案是使用QEventLoop 类，通过调用QEventLoop::exec() ，我们重入了事件循环，而且我们可以把信号连接到QEventLoop::quit() 槽上使得事件循环退出，如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QNetworkAccessManager qnam; </span><br><span class="line">QNetworkReply *reply = qnam.<span class="built_in">get</span>(QNetworkRequest(QUrl(…)));</span><br><span class="line">QEventLoop loop;</span><br><span class="line">QObject::<span class="built_in">connect</span>(reply, SIGNAL (finished()), &amp;loop, SLOT (quit()));</span><br><span class="line">loop.exec(); <span class="comment">/* reply has finished, use it */</span></span><br></pre></td></tr></table></figure>

<p>QNetworkReply doesn’t offer a blocking API and requires an event loop to be running. We enter a local QEventLoop, and when the reply has finished, the local event loop quits.</p>
<p>Be very careful when reentering the event loop “by other paths”: it can lead to unwanted recursions! Let’s go back to the Button example. If we call QCoreApplication::processEvents() inside the doWork() slot, and the user clicks again on the button, the doWork() slot will be invoked <strong>again</strong>:</p>
<p> QNetworkReply 没有提供一个阻塞式的API，而且它要求运行一个事件循环。我们进入到一个局部QEventLoop，并且当回应完成时，局部的事件循环退出。</p>
<p>当重入事件循环是从”其他路径”完成的则要非常小心：它可能会导致无尽的递归循环！让我们回到Button这个例子。如果我们再在doWork() 槽里面调用QCoreApplication::processEvents() ，这时用户又一次点击了button，那么doWork()槽将会再次被调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span>, <span class="keyword">char</span>)</span><br><span class="line">QApplication::exec()</span><br><span class="line">[…]</span><br><span class="line">QWidget::event(QEvent )</span><br><span class="line">Button::mousePressEvent(QMouseEvent)</span><br><span class="line">Button::clicked()</span><br><span class="line">[…]</span><br><span class="line">Worker::doWork() <span class="comment">// first, inner invocation</span></span><br><span class="line">QCoreApplication::processEvents() <span class="comment">// we manually dispatch events and…</span></span><br><span class="line">[…]</span><br><span class="line">QWidget::event(QEvent * ) <span class="comment">// another mouse click is sent to the Button…</span></span><br><span class="line">Button::mousePressEvent(QMouseEvent *)</span><br><span class="line">Button::clicked() <span class="comment">// which emits clicked() again…</span></span><br><span class="line">[…]</span><br><span class="line">Worker::doWork() <span class="comment">// DANG! we've recursed into our slot.</span></span><br></pre></td></tr></table></figure>

<p>A quick and easy workaround for this is passing QEventLoop::ExcludeUserInputEvents to QCoreApplication::processEvents(), which tells the event loop to not dispatch any user input event (the events will simply stay in the queue).</p>
<p>Luckily, the same thing does <strong>not</strong> apply to <strong>deletion events</strong> (the ones posted in the event queue by QObject::deleteLater()). In fact, they are handled in a special way by Qt, and are processed only if the running event loop has a smaller degree of “nesting” (w.r.t. event loops) than the one where deleteLater was called. For instance:</p>
<p>一个快速并且简单的临时解决办法是把QEventLoop::ExcludeUserInputEvents 传递给QCoreApplication::processEvents(), 也就是说，告诉事件循环不要派发任何用户输入事件（事件将简单的呆在队列中）。</p>
<p>同样地，使用一个对象的deleteLater() 来实现异步的删除事件（或者，可能引发某种”关闭（shutdown）”的任何事件）则要警惕事件循环的影响。 （译者注：deleteLater()将在事件循环中删除对象并返回）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QObject *object = <span class="keyword">new</span> QObject;</span><br><span class="line">object-&gt;deleteLater(); </span><br><span class="line">QDialog dialog;</span><br><span class="line">dialog.exec();</span><br></pre></td></tr></table></figure>

<p><strong>will not</strong> make object a dangling pointer (the event loop entered by QDialog::exec() is more nested than the deleteLater call). The same thing applies to local event loops started with QEventLoop. The only notable exception I’ve found to this rule (as of Qt 4.7.3) is that if deleteLater is called when NO event loop is running, then the first event loop entered will pick up the event and delete the object. This is pretty much reasonable, since Qt does not know about any “outer” loop that will eventually perform the deletion, and therefore deletes the object immediately.</p>
<p>可以看到，我们并没有用QCoreApplication::processEvents() (从Qt 4.3之后，删除事件不再被派发 ），但是我们确实用到了其他的局部事件循环（像我们QEventLoop 启动的这个循环，或者下面将要介绍的QDialog::exec()）。</p>
<p>切记当我们调用QDialog::exec()或者 QMenu::exec()时，Qt进入了一个局部事件循环。Qt 4.5 以后的版本，QDialog 提供了QDialog::open() 方法用来再不进入局部循环的前提下显示window-modal式的对话框</p>
<h1 id="Qt-thread-classes"><a href="#Qt-thread-classes" class="headerlink" title="Qt thread classes"></a>Qt thread classes</h1><p>Qt has had thread support for many years (Qt 2.2, released on 22 Sept 2000, introduced the QThread class.), and with the 4.0 release thread support is enabled by default on all supported platforms (although it can be turned off, see <a href="http://doc.qt.io/qt-4.8/fine-tuning-features.html" target="_blank" rel="noopener">here</a> for more details). Qt now offers several classes for dealing with threads; let’s start with an overview.</p>
<p>Qt 多年来一直支持线程（Qt 2.2，于 2000 年 9 月 22 日发布，引入了 QThread 类。），随着 4.0 版本的发布，线程支持在所有支持的平台上默认启用（尽管它可以关闭，请参见此处 更多细节）。 Qt 现在提供了几个处理线程的类； 让我们从概述开始。</p>
<h2 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h2><p><a href="http://doc.qt.io/qt-4.8/qthread.html" target="_blank" rel="noopener">QThread</a> is the central, low-level class for thread support in Qt. A QThread object represents one thread of execution. Due to the cross-platform nature of Qt, QThread manages to hide all the platform-specific code that is needed to use threads on different operating systems.</p>
<p>In order to use a QThread to run some code in a thread, we can subclass it and override the QThread::run() method:</p>
<p>QThread 是 Qt 中用于线程支持的核心低级类。 一个 QThread 对象代表一个执行线程。 由于 Qt 的跨平台特性，QThread 设法隐藏了在不同操作系统上使用线程所需的所有特定于平台的代码。</p>
<p>为了使用 QThread 在线程中运行一些代码，我们可以继承它并覆盖 QThread::run() 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* your thread implementation goes here */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Then we can use</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread *t = <span class="keyword">new</span> Thread; </span><br><span class="line">t-&gt;start(); <span class="comment">// start(), not run()!</span></span><br></pre></td></tr></table></figure>

<p>to actually start the new thread. Note that since Qt 4.4 QThread is no longer an abstract class; now the virtual method QThread::run() instead simply calls QThread::exec();, which starts the <em>thread’s event loop</em> (more info on this later).</p>
<p>为了启动新线程。 请注意，由于 Qt 4.4 QThread 不再是抽象类； 现在虚拟方法 QThread::run() 只是调用 QThread::exec();，它启动线程的事件循环（稍后会详细介绍）。</p>
<h2 id="QRunnable-and-QThreadPool"><a href="#QRunnable-and-QThreadPool" class="headerlink" title="QRunnable and QThreadPool"></a>QRunnable and QThreadPool</h2><p><a href="http://doc.qt.io/qt-4.8/qrunnable.html" target="_blank" rel="noopener">QRunnable</a> is a lightweight abstract class that can be used to start a task in another thread in a “run and forget” fashion. In order to do so, all we have to do is subclass QRunnable and implement its run() pure virtual method:</p>
<p>QRunnable 是一个轻量级的抽象类，可用于以“运行后忘记”的方式在另一个线程中启动任务。 为了做到这一点，我们所要做的就是继承 QRunnable 并实现它的 run() 纯虚方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> :</span> <span class="keyword">public</span> QRunnable &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* your runnable implementation goes here */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>To actually run a QRunnable object we use the <a href="http://doc.qt.io/qt-4.8/qthreadpool.html" target="_blank" rel="noopener">QThreadPool</a> class, which manages a pool of threads. By calling QThreadPool::start(runnable) we put a QRunnable in a QThreadPool’s runqueue; as soon as a thread becomes available, the QRunnable will be picked up and run into that thread. All Qt applications have a global thread pool available by calling QThreadPool::globalInstance(), but one can always create a private QThreadPool instance and manage it explicitely.</p>
<p>Notice that, not being a QObject, QRunnable has no built-in means of explicitely communicating something to other components; you have to code that by hand, using low-level threading primitives (like a mutex-guarded queue for collecting results, etc.).</p>
<p>为了实际运行 QRunnable 对象，我们使用 QThreadPool 类，它管理一个线程池。通过调用 QThreadPool::start(runnable) 我们将 QRunnable 放入 QThreadPool 的运行队列中；一旦线程可用，QRunnable 就会被拾取并运行到该线程中。所有 Qt 应用程序都有一个可以通过调用 QThreadPool::globalInstance() 获得的全局线程池，但是总是可以创建一个私有的 QThreadPool 实例并显式地管理它。</p>
<p>请注意，不是 QObject，QRunnable 没有内置的方法来显式地与其他组件通信。您必须使用低级线程原语（例如用于收集结果的互斥保护队列等）手动编写代码。</p>
<h2 id="QtConcurrent"><a href="#QtConcurrent" class="headerlink" title="QtConcurrent"></a>QtConcurrent</h2><p><a href="http://doc.qt.io/qt-4.8/threads-qtconcurrent.html" target="_blank" rel="noopener">QtConcurrent</a> is a higher-level API, built on top of QThreadPool, useful to deal with the most common parallel computation patterns: <a href="http://en.wikipedia.org/wiki/Map_(higher-order_function)" target="_blank" rel="noopener">map</a>, <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)" target="_blank" rel="noopener">reduce</a>, and <a href="http://en.wikipedia.org/wiki/Filter_(higher-order_function)" target="_blank" rel="noopener">filter</a> ; it also offers a QtConcurrent::run() method that can be used to easily run a function in another thread.</p>
<p>Unlike QThread and QRunnable, QtConcurrent does not require us to use low-level synchronization primitives: all QtConcurrent methods instead return a <a href="http://doc.qt.io/qt-4.8/qfuture.html" target="_blank" rel="noopener">QFuture</a> object, which can be used to query the computation status (its progress), to pause/resume/cancel the computation, and that also contains its <em>results</em>. The <a href="http://doc.qt.io/qt-4.8/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a> class can be used to monitor a QFuture progress and interact with it by means of signals and slots (notice that QFuture, being a value-based class, doesn’t inherit QObject).</p>
<p>QtConcurrent 是一个更高级别的 API，建立在 QThreadPool 之上，可用于处理最常见的并行计算模式：map、reduce 和 filter；它还提供了一个 QtConcurrent::run() 方法，可用于在另一个线程中轻松运行函数。</p>
<p>与 QThread 和 QRunnable 不同，QtConcurrent 不需要我们使用低级同步原语：所有 QtConcurrent 方法都返回一个 QFuture 对象，该对象可用于查询计算状态（其进度），暂停/恢复/取消计算，这也包含了它的结果。 QFutureWatcher 类可用于监视 QFuture 进度并通过信号和槽与其交互（请注意，QFuture 作为基于值的类，不继承 QObject）。</p>
<h2 id="Feature-comparison"><a href="#Feature-comparison" class="headerlink" title="Feature comparison"></a>Feature comparison</h2><table>
<thead>
<tr>
<th></th>
<th>QThread</th>
<th>QRunnable</th>
<th>QtConcurrent</th>
</tr>
</thead>
<tbody><tr>
<td>High level API</td>
<td>✘</td>
<td>✘</td>
<td>✔</td>
</tr>
<tr>
<td>Job-oriented</td>
<td>✘</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Builtin support for pause/resume/cancel</td>
<td>✘</td>
<td>✘</td>
<td>✔</td>
</tr>
<tr>
<td>Can run at a different priority</td>
<td>✔</td>
<td>✘</td>
<td>✘</td>
</tr>
<tr>
<td>Can run an event loop</td>
<td>✔</td>
<td>✘</td>
<td>✘</td>
</tr>
</tbody></table>
<h1 id="Threads-and-QObjects"><a href="#Threads-and-QObjects" class="headerlink" title="Threads and QObjects"></a>Threads and QObjects</h1><h2 id="Per-thread-event-loop"><a href="#Per-thread-event-loop" class="headerlink" title="Per-thread event loop"></a>Per-thread event loop</h2><p>So far we’ve always talked about “<em>the</em> event loop”, taking somehow per granted that there’s only one event loop in a Qt application. This is not the case: QThread objects can start thread-local event loops running in the threads they represent. Therefore, we say that the <strong>main event loop</strong> is the one created by the thread which invoked main(), and started with QCoreApplication::exec() (which <em>must</em> be called from that thread). This is also called the <strong>GUI thread</strong>, because it’s the only thread in which GUI-related operations are allowed. A QThread local event loop can be started instead by calling QThread::exec() (inside its run() method):</p>
<p>到目前为止，我们一直在谈论“事件循环”，以某种方式理所当然地认为 Qt 应用程序中只有一个事件循环。情况并非如此：QThread 对象可以启动在它们所代表的线程中运行的线程本地事件循环。因此，我们说主事件循环是由调用 main() 的线程创建的，并以 QCoreApplication::exec() 开始（必须从该线程调用）。这也称为 GUI 线程，因为它是唯一允许 GUI 相关操作的线程。可以通过调用 QThread::exec() （在其 run() 方法中）来启动 QThread 本地事件循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* … initialize … */</span></span><br><span class="line">		exec();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As we mentioned before, since Qt 4.4 QThread::run() is no longer a pure virtual method; instead, it calls QThread::exec(). Exactly like QCoreApplication, QThread has also the QThread::quit() and QThread::exit() methods to stop the event loop.</p>
<p>A thread event loop delivers events for all QObjects that are <strong>living</strong> in that thread; this includes, by default, all objects that are created into that thread, or that were moved to that thread (more info about this later). We also say that the <strong>thread affinity</strong> of a QObject is a certain thread, meaning that the object is living in that thread. This applies to objects which are built in the constructor of a QThread object:</p>
<p>正如我们之前提到的，从 Qt 4.4 开始，QThread::run() 不再是纯虚方法；相反，它调用 QThread::exec()。与 QCoreApplication 完全一样，QThread 也有 QThread::quit() 和 QThread::exit() 方法来停止事件循环。</p>
<p>线程事件循环为该线程中的所有 QObject 传递事件；默认情况下，这包括在该线程中创建或移动到该线程的所有对象（稍后将详细介绍）。我们也说 QObject 的线程亲和性是某个线程，这意味着该对象存在于该线程中。这适用于在 QThread 对象的构造函数中构建的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyThread()</span><br><span class="line">	&#123;</span><br><span class="line">		otherObj = <span class="keyword">new</span> QObject;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QObject obj;</span><br><span class="line">QObject *otherObj;</span><br><span class="line">QScopedPointer&lt;QObject&gt; yetAnotherObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What’s the thread affinity of obj, otherObj, yetAnotherObj after we create a MyThread object? We must look at the thread that created them: it’s the thread that ran the MyThread constructor. Therefore, all three objects are <strong>not</strong> living in the MyThread thread, but in the thread that created the MyThread instance (which, by the way, is where the instance is living as well).</p>
<p>We can query anytime the thread affinity of a QObject by calling QObject::thread(). Notice that QObjects created before a QCoreApplication object have <strong>no thread affinity</strong>, and therefore no event dispatching will be done for them (in other words, QCoreApplication builds up the QThread object that represents the main thread).</p>
<p>创建 MyThread 对象后，obj、otherObj、yetAnotherObj 的线程亲和度是多少？我们必须查看创建它们的线程：它是运行 MyThread 构造函数的线程。因此，所有三个对象都不存在于 MyThread 线程中，而是存在于创建 MyThread 实例的线程中（顺便说一句，它也是实例所在的位置）。</p>
<p>我们可以随时通过调用 QObject::thread() 查询 QObject 的线程亲和性。请注意，在 QCoreApplication 对象之前创建的 QObjects 没有线程关联，因此不会为它们进行事件分派（换句话说，QCoreApplication 构建了代表主线程的 QThread 对象）。</p>
<p><img src="http://doc.qt.io/qt-4.8/images/threadsandobjects.png" alt="threadsandobjects.png"></p>
<p>We can use the thread-safe QCoreApplication::postEvent() method for posting an event for a certain object. This will enqueue the event in the event loop of the thread the object is living in; therefore, the event will not be dispatched unless that thread has a running event loop.</p>
<p>It is very important to understand that QObject and all of its subclasses <strong>are not thread-safe</strong> (although they can be reentrant); therefore, you can not access a QObject from more than one thread at the same time, unless you serialize all accesses to the object’s internal data (for instance, by protecting it with a mutex). Remember that the object may be handling events dispatched by the event loop of the thread it is living in while you’re accessing it from another thread! For the same reason, you can’t delete a QObject from another thread, but you must use QObject::deleteLater(), which will post an event that will ultimately cause its deletion by the thread the object is living in.</p>
<p>Moreover, QWidget and all of its subclasses, along with other GUI-related classes (even not QObject-based, like QPixmap) <strong>are not reentrant</strong> either: they can be used exclusively from the GUI thread.</p>
<p>We can change a QObject’s affinity by calling QObject::moveToThread(); this will change the affinity of the object and of its children. Since QObject is not thread-safe, we must use it from the thread the object is living in; that is, you can only <strong>push</strong> objects from the thread they’re living in to other threads, and not <strong>pull</strong> them or move them around from other threads. Moreover, Qt requires that the child of a QObject must live in the same thread where the parent is living. This implies that:</p>
<ul>
<li>you can’t use QObject::moveToThread() on a object which has a parent;</li>
<li>you must not create objects in a QThread using the QThread object itself as their parent:</li>
</ul>
<p>我们可以使用线程安全的 QCoreApplication::postEvent() 方法为某个对象发布事件。这会将事件排入对象所在线程的事件循环中；因此，除非该线程具有正在运行的事件循环，否则不会分派事件。</p>
<p>了解 QObject 及其所有子类都不是线程安全的（尽管它们可以是可重入的），这一点非常重要；因此，您不能同时从多个线程访问一个 QObject，除非您序列化对对象内部数据的所有访问（例如，通过使用互斥锁保护它）。请记住，当您从另一个线程访问它时，该对象可能正在处理由它所在线程的事件循环分派的事件！出于同样的原因，你不能从另一个线程中删除一个 QObject，但你必须使用 QObject::deleteLater()，它会发布一个事件，最终导致对象所在的线程将其删除。</p>
<p>此外，QWidget 及其所有子类，以及其他与 GUI 相关的类（甚至不是基于 QObject，如 QPixmap）也不是可重入的：它们只能从 GUI 线程中使用。</p>
<p>我们可以通过调用 QObject::moveToThread(); 来改变 QObject 的亲和性。这将改变对象及其子对象的亲和力。由于 QObject 不是线程安全的，我们必须从对象所在的线程中使用它；也就是说，您只能将对象从它们所在的线程推送到其他线程，而不能从其他线程中拉出或移动它们。此外，Qt 要求 QObject 的子级必须与父级所在的线程相同。这意味着：</p>
<p>你不能在有父对象的对象上使用 QObject::moveToThread() ；<br>您不能使用 QThread 对象本身作为其父对象在 QThread 中创建对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		QObject *obj = <span class="keyword">new</span> QObject(<span class="keyword">this</span>); <span class="comment">// WRONG[[Image:|Image:]]!</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is because the <strong>QThread object is living in another thread</strong>, namely, the one in which it was created.</p>
<p>Qt also requires that all objects living in a thread are deleted before the QThread object that represents the thread is destroyed; this can be easily done by creating all the objects living in that thread on the QThread::run() method’s stack.</p>
<p>这是因为 QThread 对象存在于另一个线程中，即创建它的那个线程。</p>
<p>Qt 还要求在代表线程的 QThread 对象被销毁之前删除所有存在于线程中的对象； 这可以通过在 QThread::run() 方法的堆栈上创建该线程中的所有对象来轻松完成。</p>
<h2 id="Signals-and-slots-across-threads"><a href="#Signals-and-slots-across-threads" class="headerlink" title="Signals and slots across threads"></a>Signals and slots across threads</h2><p>Given these premises, how do we call methods on QObjects living in other threads? Qt offers a very nice and clean solution: we post an event in that thread’s event queue, and the handling of that event will consist in invoking the method we’re interested in (this of course requires that the thread has a running event loop). This facility is built around the method introspection provided by moc: therefore, only signals, slots and methods marked with the Q_INVOKABLE macro are invokable from other threads.</p>
<p>The QMetaObject::invokeMethod() static method does all the work for us:</p>
<p>鉴于这些前提，我们如何调用位于其他线程中的 QObject 上的方法？ Qt 提供了一个非常好的和干净的解决方案：我们在该线程的事件队列中发布一个事件，该事件的处理将包括调用我们感兴趣的方法（这当然需要线程有一个正在运行的事件循环） .这个工具是围绕 moc 提供的方法自省构建的：因此，只有用 Q_INVOKABLE 宏标记的信号、槽和方法才能从其他线程调用。</p>
<p>QMetaObject::invokeMethod() 静态方法为我们完成了所有工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject::invokeMethod(object, <span class="string">"methodName"</span>,Qt::QueuedConnection, Q_ARG(type1, arg1), Q_ARG(type2, arg2));</span><br></pre></td></tr></table></figure>

<p>Notice that since the arguments need to be copied in the event which is built behind the scenes, their types need to provide a public constructor, a public destructor and a public copy constructor, and must be registered within Qt type system by using the qRegisterMetaType() function.</p>
<p>Signals and slots across threads work in a similar way. When we connect a signal to a slot, the fifth argument of QObject::connect is used to specify the connection type:</p>
<ul>
<li>a <strong>direct connection</strong> means that the slot is always invoked directly by the thread the signal is emitted from;</li>
<li>a <strong>queued connection</strong> means that an event is posted in the event queue of the thread the receiver is living in, which will be picked up by the event loop and will cause the slot invocation sometime later;</li>
<li>a <strong>blocking queued connection</strong> is like a queued connection, but the sender thread blocks until the event is picked up by the event loop of the thread the receiver is living in, the slot is invoked, and it returns;</li>
<li>an <strong>automatic connection</strong> (<em>the default</em>) means that if the thread the receiver is living in is the same as the current thread, a direct connection is used; otherwise, a queued connection is used.</li>
</ul>
<p>In every case, keep in mind <em>the thread the emitting object is living in</em> has no importance at all! In case of an automatic connection, Qt looks at the thread that invoked the signal and compares it with the thread the receiver is living in to determine which connection type it has to use. In particular, the <a href="http://doc.qt.io/qt-5/threads-qobject.html" target="_blank" rel="noopener">current Qt documentation</a> <strong>is simply wrong</strong> when it states:</p>
<p><em>Auto Connection (default) The behavior is the same as the Direct Connection, if the emitter and receiver are in the same thread. The behavior is the same as the Queued Connection, if the emitter and receiver are in different threads.</em></p>
<p>because the emitter object’s thread affinity does not matter. For instance: </p>
<p>请注意，由于在幕后构建的事件中需要复制参数，因此它们的类型需要提供公共构造函数、公共析构函数和公共复制构造函数，并且必须使用 qRegisterMetaType( ） 功能。</p>
<p>跨线程的信号和槽以类似的方式工作。当我们将信号连接到槽时，QObject::connect 的第五个参数用于指定连接类型：</p>
<ul>
<li><p><strong>direct connection</strong>直接连接意味着槽总是由发出信号的线程直接调用；</p>
</li>
<li><p><strong>queued connection</strong>排队连接意味着一个事件被发布到接收者所在线程的事件队列中，该事件将被事件循环拾取并在稍后的某个时间导致插槽调用；</p>
</li>
<li><p><strong>blocking queued connection</strong>阻塞队列连接类似于队列连接，但是发送者线程阻塞，直到接收者所在线程的事件循环拾取事件，调用槽，然后返回；</p>
</li>
<li><p><strong>automatic connection</strong>自动连接（默认）意味着如果接收者所在的线程与当前线程相同，则使用直接连接；否则，使用排队连接</p>
<p>在任何情况下，请记住发射对象所在的线程根本不重要！在自动连接的情况下，Qt 查看调用信号的线程并将其与接收者所在的线程进行比较以确定它必须使用哪种连接类型。特别是，当前的 Qt 文档在声明时是完全错误的：</p>
</li>
</ul>
<p>自动连接（默认） 如果发射器和接收器在同一个线程中，则行为与直接连接相同。如果发射器和接收器在不同的线程中，则行为与排队连接相同。</p>
<p>因为发射器对象的线程亲和性无关紧要。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">signals:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">aSignal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="function">emit <span class="title">aSignal</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* … */</span> </span><br><span class="line">Thread thread;</span><br><span class="line">Object obj;</span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;thread, SIGNAL (aSignal()), &amp;obj, SLOT (aSlot()));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>The signal aSignal() will be emitted by the new thread (represented by the Thread object); since it is not the thread the Object object is living in (which, by the way, <strong>is the same thread the Thread object is living in</strong>, just to stress that the sender’s thread affinity doesn’t matter), a <strong>queued connection</strong> will be used.</p>
<p>Another common pitfall is the following one:</p>
<p>信号 aSignal() 将由新线程发出（由 Thread 对象表示）； 因为它不是 Object 对象所在的线程（顺便说一下，它与 Thread 对象所在的线程相同，只是为了强调发送者的线程亲和性无关紧要），将使用排队连接 .</p>
<p>另一个常见的陷阱如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">aSlot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* … */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	/ … */</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/ … */ </span><br><span class="line">Thread thread; </span><br><span class="line">Object obj; </span><br><span class="line">QObject::<span class="built_in">connect</span>(&amp;obj, SIGNAL (aSignal()), &amp;thread, SLOT (aSlot())); </span><br><span class="line">thread.start(); </span><br><span class="line">obj.emitSignal();</span><br></pre></td></tr></table></figure>

<p>When “obj” emits its aSignal() signal, which kind of connection will be used? You should’ve guessed it: a <strong>direct connection</strong>. That’s because the Thread object is living in the thread that emits the signal. In the aSlot() slot we could then access some Thread’s member variable while they’re being accessed by the run() method, which is running concurrently: this is the perfect recipe for disaster.</p>
<p>Yet another example, probably the <em>most important</em> one:</p>
<p>当“obj”发出它的 aSignal() 信号时，将使用哪种连接？ 您应该已经猜到了：直接连接。 那是因为 Thread 对象存在于发出信号的线程中。 在 aSlot() 槽中，我们可以在同时运行的 run() 方法访问某些 Thread 的成员变量时访问它们：这是灾难的完美秘诀。</p>
<p>还有一个例子，可能是最重要的一个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">	slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">aSlot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* … */</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		QObject *obj = <span class="keyword">new</span> Object;</span><br><span class="line">		<span class="built_in">connect</span>(obj, SIGNAL (aSignal()), <span class="keyword">this</span>, SLOT (aSlot()));</span><br><span class="line">		<span class="comment">/* … */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In this case a <strong>queued connection</strong> is used, therefore you’re required to run an event loop in the thread the Thread object is living in.</p>
<p>A solution you’ll often found in forums, blog posts etc. is to add a moveToThread(this) to the Thread constructor:</p>
<p>在这种情况下，使用排队连接，因此您需要在 Thread 对象所在的线程中运行事件循环。</p>
<p>您经常在论坛、博客文章等中找到的解决方案是将 moveToThread(this) 添加到 Thread 构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Thread() &#123;</span><br><span class="line">		moveToThread(<span class="keyword">this</span>); <span class="comment">// WRONG</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* … */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>which indeed <em>will work</em> (because now the affinity of the Thread object changed), but it’s a very bad design. What’s wrong here is that we’re misunderstanding the purpose of a thread object (the QThread subclass): <em>QThread objects are not threads</em>; they’re control objects around a thread, therefore meant to be used from another thread (usually, the one they’re living in).</p>
<p><strong>A good way to achieve the same result</strong> is splitting the “working” part from the “controller” part, that is, writing a QObject subclass and using QObject::moveToThread() to change its affinity:</p>
<p>这确实会起作用（因为现在 Thread 对象的亲和力发生了变化），但这是一个非常糟糕的设计。这里的问题是我们误解了线程对象（QThread 子类）的用途：QThread 对象不是线程；它们是线程周围的控制对象，因此意味着可以从另一个线程（通常是它们所在的线程）使用。</p>
<p>实现相同结果的一个好方法是将“工作”部分与“控制器”部分分开，即编写一个 QObject 子类并使用 QObject::moveToThread() 来更改其亲和性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* … */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* … */</span></span><br><span class="line">QThread *thread = <span class="keyword">new</span> QThread;</span><br><span class="line">Worker *worker = <span class="keyword">new</span> Worker;</span><br><span class="line"><span class="built_in">connect</span>(obj, SIGNAL (workReady()), worker, SLOT (doWork()));</span><br><span class="line">worker-&gt;moveToThread(thread);</span><br><span class="line">thread-&gt;start();</span><br></pre></td></tr></table></figure>

<h2 id="DOs-and-DON’Ts"><a href="#DOs-and-DON’Ts" class="headerlink" title="DOs and DON’Ts"></a>DOs and DON’Ts</h2><h3 id="You-can…"><a href="#You-can…" class="headerlink" title="You can…"></a>You can…</h3><p><strong>… add signals to a QThread subclass. It’s perfectly safe and they’ll do the “right thing” (see above; the sender’s thread affinity does not matter).</strong></p>
<p>将信号添加到 QThread 子类。 这是完全安全的，他们会做“正确的事”（见上文；发件人的线程亲和力无关紧要）。</p>
<h3 id="You-shouldn’t-…"><a href="#You-shouldn’t-…" class="headerlink" title="You shouldn’t …"></a>You shouldn’t …</h3><ul>
<li>… use moveToThread(this).</li>
<li>… force the connection type: this usually means that you’re doing something wrong, like mixing the control interface of QThread with the program logic (which should stay in a separate object which lives in that thread).</li>
<li>… add slots to a QThread subclass: they’ll be invoked from the “wrong” thread, that is, not the one the QThread object is managing, but the one that object is living in, forcing you to specify a direct connection and/or to use moveToThread(this).</li>
<li>… use QThread::terminate.</li>
</ul>
<p>不该做的</p>
<ul>
<li>使用moveToThread(this).</li>
<li>强制连接类型：这通常意味着您做错了什么，例如将 QThread 的控制接口与程序逻辑混合在一起（它应该保留在该线程中的单独对象中）。</li>
<li>将插槽添加到 QThread 子类：它们将从“错误”线程调用，也就是说，不是 QThread 对象正在管理的线程，而是该对象所在的线程，迫使您指定直接连接和/或 使用 moveToThread(this)。</li>
<li>使用QThread::terminate</li>
</ul>
<h3 id="You-must-not…"><a href="#You-must-not…" class="headerlink" title="You must not…"></a>You must not…</h3><ul>
<li>… quit your program when threads are still running. Use QThread::wait to wait for their termination.</li>
<li>… destroy a QThread while the thread that it’s managing is still running. If you want some kind of “self-destruction”, you can connect the finished() signal with the deleteLater() slot.</li>
<li>当线程仍在运行时退出程序。 使用 QThread::wait 等待它们的终止。</li>
<li>在它管理的线程仍在运行时销毁 QThread。 如果你想要某种“自毁”，你可以将finished() 信号与deleteLater() 槽连接起来。</li>
</ul>
<h1 id="When-should-I-use-threads"><a href="#When-should-I-use-threads" class="headerlink" title="When should I use threads?"></a>When should I use threads?</h1><h2 id="When-you-have-to-use-a-blocking-API"><a href="#When-you-have-to-use-a-blocking-API" class="headerlink" title="When you have to use a blocking API"></a>When you have to use a blocking API</h2><p>If you need to use a library or other code that doesn’t offer a non-blocking API (by means of signals and slots, or events, or callbacks, etc.), then the only viable solution in order to avoid freezing the event loop is to spawn a process or a thread. Since creating a new worker process, having it doing the job and communicating back the results is definetely harder and more expensive than just starting a thread, the latter is the most common choice.</p>
<p>A good example of such an API is <strong>address resolution</strong> (just to show you that we’re not talking about 3rd-party crappy API. This is something included in every C library out there), which is the process of taking an host name and converting it into an address. This process involves a query to a (usually remote) system — the Domain Name System, or DNS. While, usually, the response is almost instantaneous, the remote servers might fail, some packet might get lost, the network connection might break, and so on; in short, it might take dozens of seconds before we get a reply from our query.</p>
<p>The only standard API available on UNIX systems is <em>blocking</em> (not only the old-fashioned gethostbyname(3), but also the newer and better getservbyname(3) and getaddrinfo(3)). <a href="http://doc.qt.io/qt-4.8/qhostinfo.html" target="_blank" rel="noopener">QHostInfo</a>, the Qt class that handles host name lookups, uses a QThreadPool to enable the queries to run in the background (see <a href="http://code.qt.io/cgit/qt/qt.git/tree/src/network/kernel/qhostinfo.cpp" target="_blank" rel="noopener">here</a> ; if thread support is turned off, it switches back to a blocking API).</p>
<p>Other simple examples are <strong>image loading</strong> and <strong>scaling</strong>. <a href="http://doc.qt.io/qt-4.8/qimagereader.html" target="_blank" rel="noopener">QImageReader</a> and <a href="http://doc.qt.io/qt-4.8/qimage.html" target="_blank" rel="noopener">QImage</a> only offer blocking methods to read an image from a device, or to scale an image to a different resolution. If you’re dealing with very large images, these processes can take up to (tens of) seconds.</p>
<p>如果您需要使用不提供非阻塞 API 的库或其他代码（通过信号和插槽、事件或回调等），那么唯一可行的解决方案是避免冻结事件循环是产生一个进程或线程。由于创建一个新的工作进程，让它完成工作并反馈结果肯定比仅仅启动一个线程更难，更昂贵，后者是最常见的选择。</p>
<p>这种 API 的一个很好的例子是地址解析（只是为了告诉你我们不是在谈论 3rd-party 糟糕的 API。这是每个 C 库中都包含的东西），这是获取主机名和将其转换为地址。此过程涉及对（通常是远程）系统的查询——域名系统或 DNS。虽然通常响应几乎是即时的，但远程服务器可能会失败，某些数据包可能会丢失，网络连接可能会中断，等等；简而言之，我们可能需要几十秒才能从查询中得到回复。</p>
<p>UNIX 系统上唯一可用的标准 API 是阻塞（不仅是老式的 gethostbyname(3)，还有更新更好的 getservbyname(3) 和 getaddrinfo(3)）。 QHostInfo 是处理主机名查找的 Qt 类，它使用 QThreadPool 使查询能够在后台运行（参见此处；如果线程支持被关闭，它会切换回阻塞 API）。</p>
<p>其他简单的例子是图像加载和缩放。 QImageReader 和 QImage 仅提供从设备读取图像或将图像缩放到不同分辨率的阻塞方法。如果您正在处理非常大的图像，这些过程可能需要（数十）秒。</p>
<h2 id="When-you-want-to-scale-with-the-number-of-CPUs"><a href="#When-you-want-to-scale-with-the-number-of-CPUs" class="headerlink" title="When you want to scale with the number of CPUs"></a>When you want to scale with the number of CPUs</h2><p>Threads allow your program to take advantage from multiprocessor systems. Since each thread is scheduled independently by the operating system, if your application is running on such a machine the scheduler is likely to run each thread on a different processor <strong>at the same time</strong>.</p>
<p>For instance, consider an application that generates thumbnails from a set of images. A <strong>thread farm</strong> of <em>n</em> threads (that is, a thread pool with a fixed number of threads), one per each CPU available in the system (see also QThread::idealThreadCount() ), can spread the work of scaling down the images into thumbnails on all the threads, effectively gaining an almost linear speedup with the number of the processors (for simplicity’s sake, we consider the CPU being the bottleneck).</p>
<p>线程允许您的程序利用多处理器系统。由于每个线程都是由操作系统独立调度的，如果您的应用程序在这样的机器上运行，那么调度程序很可能同时在不同的处理器上运行每个线程。</p>
<p>例如，考虑一个从一组图像生成缩略图的应用程序。 n 个线程的线程场（即具有固定数量线程的线程池），每个系统中可用的 CPU 一个（另请参见 QThread::idealThreadCount() ），可以将缩小图像的工作分散到所有线程的缩略图，有效地获得处理器数量的几乎线性加速（为简单起见，我们认为 CPU 是瓶颈）。</p>
<h2 id="When-you-don’t-want-to-be-possibly-blocked-by-others"><a href="#When-you-don’t-want-to-be-possibly-blocked-by-others" class="headerlink" title="When you don’t want to be possibly blocked by others"></a>When you don’t want to be possibly blocked by others</h2><p>MEH. BETTER START WITH AN EXAMPLE.</p>
<p>This is quite an advanced topic, so feel free to skip it for now. A nice example of this use case comes from QNetworkAccessManager usage inside WebKit. WebKit is a modern browser engine, that is, a set of classes to lay out and display web pages. The Qt widget that uses WebKit is QWebView.</p>
<p>QNetworkAccessManager is a Qt class that deals with HTTP requests and responses for all purposes, we can consider it to be the networking engine of a web browser. Before Qt 4.8, it does not make use of any worker threads; all networking is handled in the same thread QNetworkAccessManager and its QNetworkReplys are living in.</p>
<p>While not using threads for networking is a very good idea, it has also a major drawback: if you don’t read data from the socket as soon as possible, the kernel buffers will fill up, packets will begin to be dropped, and the transfer speed will decrease considerably.</p>
<p>Socket activity (i.e., availability of some data to read from a socket) is managed by Qt’s event loop. Blocking the event loop will therefore lead to a loss of transfer performance, because nobody will be notified that there are data to read (and thus nobody will read them).</p>
<p>But what could block the event loop? The sad answer is: WebKit itself! As soon as some data are received, WebKit uses them to start laying out the web page. Unfortunately, the layout process is quite complicated and expensive, therefore it blocks the event loop for a (short) while, enough to impact on ongoing transfers (broadband connections play their role here, filling up kernel buffers in a small fraction of second).</p>
<p>To sum it up, what happens is something like this:</p>
<ul>
<li>WebKit issues a request;</li>
<li>some data from the reply begin to arrive;</li>
<li>WebKit starts to lay out the web page using the incoming data, blocking the event loop;</li>
<li>without a running event loop, data are received by the OS, but not read from QNetworkAccessManager sockets;</li>
<li>kernel buffers will fill up, and the transfer will slow down.</li>
</ul>
<p>The overall page loading time is therefore worsened by this self-induced transfer slowness.</p>
<p>Notice that since QNetworkAccessManagers and QNetworkReplys are QObjects, they’re not thread-safe, therefore you can’t just move them to another thread and continue using them from your thread, because they may be accessed at the same time by two threads: yours and the one they’re living in, due to events that will be dispatched to them by the latter thread’s event loop.</p>
<p>As of Qt 4.8, QNetworkAccessManager now handles HTTP requests in a separate thread by default, so the result of unresponsive GUI and OS buffers filling up too quickly should be cured.</p>
<p>嗯。更好地从一个例子开始。</p>
<p>这是一个相当高级的话题，所以现在可以跳过它。这个用例的一个很好的例子来自 WebKit 中的 QNetworkAccessManager 使用。 WebKit 是一种现代浏览器引擎，即一组用于布局和显示网页的类。使用 WebKit 的 Qt 小部件是 QWebView。</p>
<p>QNetworkAccessManager 是一个处理各种用途的 HTTP 请求和响应的 Qt 类，我们可以将其视为 Web 浏览器的网络引擎。在 Qt 4.8 之前，它不使用任何工作线程；所有网络都在同一个线程 QNetworkAccessManager 中处理，它的 QNetworkReplys 存在于其中。</p>
<p>虽然不使用线程进行联网是一个非常好的主意，但它也有一个主要缺点：如果您不尽快从套接字读取数据，内核缓冲区将填满，数据包将开始被丢弃，并且传输速度将大大降低。</p>
<p>套接字活动（即从套接字读取的某些数据的可用性）由 Qt 的事件循环管理。因此阻塞事件循环将导致传输性能损失，因为没有人会被通知有数据要读取（因此没有人会读取它们）。</p>
<p>但是什么会阻止事件循环呢？可悲的答案是：WebKit 本身！一旦收到一些数据，WebKit 就会使用它们开始布局网页。不幸的是，布局过程非常复杂和昂贵，因此它会阻塞事件循环（短）一段时间，足以影响正在进行的传输（宽带连接在这里发挥作用，在几分之一秒内填满内核缓冲区）。</p>
<p>总而言之，发生的事情是这样的：</p>
<p>WebKit 发出请求；<br>回复中的一些数据开始到达；<br>WebKit 开始使用传入的数据布局网页，阻塞事件循环；<br>如果没有正在运行的事件循环，操作系统会接收数据，但不会从 QNetworkAccessManager 套接字中读取数据；<br>内核缓冲区将被填满，传输将减慢。<br>因此，这种自引起的传输速度变慢会使整个页面加载时间恶化。</p>
<p>请注意，由于 QNetworkAccessManagers 和 QNetworkReplys 是 QObjects，它们不是线程安全的，因此您不能将它们移动到另一个线程并继续从您的线程中使用它们，因为它们可能同时被两个线程访问：你的和他们居住的那个，因为事件将由后一个线程的事件循环分派给他们。</p>
<p>从 Qt 4.8 开始，QNetworkAccessManager 现在默认在单独的线程中处理 HTTP 请求，因此应该解决无响应的 GUI 和操作系统缓冲区过快填满的结果。</p>
<h1 id="When-shouldn’t-I-use-threads"><a href="#When-shouldn’t-I-use-threads" class="headerlink" title="When shouldn’t I use threads?"></a>When shouldn’t I use threads?</h1><h2 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h2><p>This is perhaps the worst form of thread abuse. If we have to invoke a method repeatedly (for instance, every second), many people end up with something like this:</p>
<p>这可能是最糟糕的线程滥用形式。 如果我们必须重复调用一个方法（例如，每秒），很多人最终会得到这样的结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VERY WRONG </span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">	doWork();</span><br><span class="line">	sleep(<span class="number">1</span>); <span class="comment">// this is sleep(3) from the C library</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then they figure out that this is <strong>blocking the event loop</strong>, therefore decide to bring in threads:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> :</span> <span class="keyword">public</span> QThread &#123; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (condition) &#123;</span><br><span class="line">			<span class="comment">// notice that "condition" may also need volatiness and mutex protection</span></span><br><span class="line">			<span class="comment">// if we modify it from other threads (!)</span></span><br><span class="line">			doWork();</span><br><span class="line">			sleep(<span class="number">1</span>); <span class="comment">// this is QThread::sleep()</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A much <strong>better and simpler way</strong> of achieving the same result is simply using timers, i.e. a <a href="http://doc.qt.io/qt-4.8/qtimer.html" target="_blank" rel="noopener">QTimer</a> object with a 1s timeout, and make the doWork() method a slot:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Worker() &#123;		</span><br><span class="line">		<span class="built_in">connect</span>(&amp;timer, SIGNAL (timeout()), <span class="keyword">this</span>, SLOT (doWork()));</span><br><span class="line">		timer.start(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* … */</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>All we need is a running event loop, then the doWork() method will be invoked each second.</p>
<p>我们只需要一个正在运行的事件循环，然后每秒都会调用 doWork() 方法。</p>
<h2 id="Networking-state-machines"><a href="#Networking-state-machines" class="headerlink" title="Networking / state machines"></a>Networking / state machines</h2><p>A very common design pattern when dealing with network operations is the following one:</p>
<p>在处理网络操作时，一种非常常见的设计模式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">socket-&gt;<span class="built_in">connect</span>(host);</span><br><span class="line">socket-&gt;waitForConnected();</span><br><span class="line">data = getData();</span><br><span class="line">socket-&gt;<span class="built_in">write</span>(data);</span><br><span class="line">socket-&gt;waitForBytesWritten();</span><br><span class="line">socket-&gt;waitForReadyRead();</span><br><span class="line">socket-&gt;<span class="built_in">read</span>(response);</span><br><span class="line">reply = <span class="built_in">process</span>(response);</span><br><span class="line">socket-&gt;<span class="built_in">write</span>(reply);</span><br><span class="line">socket-&gt;waitForBytesWritten(); <span class="comment">/* … and so on … */</span></span><br></pre></td></tr></table></figure>

<p>Needless to say, the various waitFor<strong>() calls block the caller without returning to the event loop, freezing the UI and so on. Notice that the above snippet does not take into account any error handling, otherwise it would have been even more cumbersome. What is very wrong in this design is that we’re forgetting that</strong> networking is asynchronous by design<strong>, and if we build a synchronous processing around we’re shooting ourselves in the foot. To solve this problem, many people simple move this code into a different thread.</strong></p>
<p>不用说，各种 waitFor() 调用会阻塞调用者而不返回事件循环、冻结 UI 等等。请注意，上面的代码段没有考虑任何错误处理，否则会更加麻烦。这种设计的严重错误在于，我们忘记了网络在设计上是异步的，如果我们围绕着构建同步处理，我们就是在自找麻烦。为了解决这个问题，许多人简单地将这段代码移动到不同的线程中。</p>
<p>Another more abstract example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result = process_one_thing();</span><br><span class="line"><span class="keyword">if</span> (result-&gt;something())</span><br><span class="line">	process_this();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	process_that();</span><br><span class="line">wait_for_user_input();</span><br><span class="line">input = read_user_input(); </span><br><span class="line">process_user_input(input); <span class="comment">/* … */</span></span><br></pre></td></tr></table></figure>

<p>Which has more or less the same pitfalls of the networking example.</p>
<p>Let’s take a step back and consider from an higher point of view what we’re building here: we want to create a <strong>state machine</strong> that reacts on inputs of some sort and acts consequently. For instance, with the networking example, we might want to build something like this:</p>
<p> 这与网络示例具有或多或少相同的陷阱。</p>
<p>让我们退后一步，从更高的角度考虑我们在这里构建的内容：我们想要创建一个状态机，它对某种输入做出反应并采取相应的行动。 例如，对于网络示例，我们可能想要构建这样的东西：</p>
<ul>
<li>Idle → Connecting (when calling connectToHost());</li>
<li>Connecting → Connected (when connected() is emitted);</li>
<li>Connected → LoginDataSent (when we send the login data to the server);</li>
<li>LoginDataSent → LoggedIn (the server replied with an ACK)</li>
<li>LoginDataSent → LoginError (the server replied with a NACK)</li>
</ul>
<p>and so forth.</p>
<p>等等。</p>
<p>Now, there are several ways to build a state machine (and Qt even offers a class for that: <a href="http://doc.qt.io/qt-5/qstatemachine.html" target="_blank" rel="noopener">QStateMachine</a> ), the simplest one being an enum (i.e. an integer) used to remember the current state. We can rewrite the above snippets like this:</p>
<p>现在，有几种方法可以构建状态机（Qt 甚至为此提供了一个类： QStateMachine ），最简单的一种是用于记住当前状态的枚举（即整数）。 我们可以像这样重写上面的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">	<span class="keyword">enum</span> State &#123;</span><br><span class="line">		State1, State2, State3 <span class="comment">/* and so on */</span></span><br><span class="line">	&#125;;</span><br><span class="line">State state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Object() : state(State1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">connect</span>(source, SIGNAL (<span class="built_in">ready</span>()), <span class="keyword">this</span>, SLOT (doWork()));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">		<span class="keyword">case</span> State1:</span><br><span class="line">		<span class="comment">/* … */</span></span><br><span class="line">		state = State2;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> State2:</span><br><span class="line">		<span class="comment">/* … */</span></span><br><span class="line">		state = State3;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/* etc. */</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What the “source” object and its “ready()” signal are? Exactly what we want them to be: for instance, in the networking example, we might want to connect the socket’s QAbstractSocket::connected() and the QIODevice::readyRead() signals to our slot. Of course, we can also easily add more slots if that suits better in our case (like a slot to manage error situations, which are notified by the QAbstractSocket::error() signal). This is a true asynchronous, signal-driven design!</p>
<p>“源”对象及其“ready()”信号是什么？ 正是我们希望它们成为的样子：例如，在网络示例中，我们可能希望将套接字的 QAbstractSocket::connected() 和 QIODevice::readyRead() 信号连接到我们的插槽。 当然，如果更适合我们的情况，我们也可以轻松添加更多插槽（例如管理错误情况的插槽，由 QAbstractSocket::error() 信号通知）。 这是一个真正的异步、信号驱动设计！</p>
<h2 id="Jobs-splittable-in-chunks"><a href="#Jobs-splittable-in-chunks" class="headerlink" title="Jobs splittable in chunks"></a>Jobs splittable in chunks</h2><p>可分块的作业</p>
<p>Suppose that we have a long computation which can’t be easily moved to another thread (or that it can’t be moved at all, because for instance it <em>must run</em> in the GUI thread). If <strong>we can split the computation in small chunks</strong>, we can return to the event loop, let it dispatch events, and make it invoke the method that processes the next chunk. This can be easily done if we remember how queued connections are implemented: an event is posted in the event loop of the thread the receiver object is living in; when the event is delivered, the corresponding slot is invoked.</p>
<p>We can use QMetaObject::invokeMethod() to achieve the same result by specifying Qt::QueuedConnection as the type of the invocation; this just requires the method to be invokable, therefore it must be either a slot or marked with the Q_INVOKABLE macro. If we also want to pass parameters to the method, they need to be registered within the Qt metatype system using qRegisterMetaType(). The following snippet shows this pattern:</p>
<p>假设我们有一个很长的计算不能轻易移动到另一个线程（或者它根本不能移动，因为例如它必须在 GUI 线程中运行）。如果我们可以将计算分成小块，我们可以返回事件循环，让它分派事件，并让它调用处理下一个块的方法。如果我们记得队列连接是如何实现的，这很容易做到：一个事件被发布到接收者对象所在线程的事件循环中；当事件被传递时，相应的槽被调用。</p>
<p>我们可以使用 QMetaObject::invokeMethod() 通过指定 Qt::QueuedConnection 作为调用的类型来实现相同的结果；这只要求方法是可调用的，因此它必须是一个插槽或用 Q_INVOKABLE 宏标记。如果我们还想将参数传递给方法，则需要使用 qRegisterMetaType() 在 Qt 元类型系统中注册它们。以下代码段显示了这种模式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">startProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		processItem(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">processItem</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">/* process items[index] … */</span></span><br><span class="line">		<span class="keyword">if</span> (index &lt; numberOfItems)</span><br><span class="line">			QMetaObject::invokeMethod(<span class="keyword">this</span>,<span class="string">"processItem"</span>,Qt::QueuedConnection,Q_ARG(<span class="keyword">int</span>, index + <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Since there are no threads involved, it’s easy to pause/resume/cancel such a computation and collect the results back.</p>
<p>由于不涉及线程，因此很容易暂停/恢复/取消此类计算并收集结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/20/D-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/D-Pointer/" class="post-title-link" itemprop="url">D-Pointer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-20 22:49:44" itemprop="dateCreated datePublished" datetime="2022-09-20T22:49:44+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-24 12:11:20" itemprop="dateModified" datetime="2022-09-24T12:11:20+08:00">2022-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/QT/" itemprop="url" rel="index"><span itemprop="name">QT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="What-is-the-d-pointer"><a href="#What-is-the-d-pointer" class="headerlink" title="What is the d-pointer"></a>What is the d-pointer</h3><p>If you have looked into Qt source files like <a href="http://code.qt.io/cgit/qt/qtbase.git/tree/src/widgets/widgets/qlabel.cpp" target="_blank" rel="noopener">this one</a>, you will find it generously sprinkled with <code>Q_D</code> and <code>Q_Q</code> macros. This article unravels the purpose of these macros.</p>
<p>The <code>Q_D</code> and <code>Q_Q</code> macros are part of a design pattern called the <em>d-pointer</em> (also called the <em><a href="http://en.wikipedia.org/wiki/Opaque_pointer" target="_blank" rel="noopener">opaque pointer</a></em>) where the implementation details of a library may be hidden from its users and changes to the implementation can be made to a library without breaking binary compatibility.</p>
<p>如果您查看过类似这样的 Qt 源文件，您会发现它大量使用了 Q_D 和 Q_Q 宏。 本文揭示了这些宏的用途。</p>
<p>Q_D 和 Q_Q 宏是称为 d 指针（也称为不透明指针）的设计模式的一部分，其中库的实现细节可能对其用户隐藏，并且可以在不破坏二进制文件的情况下对库进行实现更改 兼容性。</p>
<h3 id="Binary-compatibility-—-what-is-that"><a href="#Binary-compatibility-—-what-is-that" class="headerlink" title="Binary compatibility — what is that?"></a>Binary compatibility — what is that?</h3><p>When designing libraries like Qt, it is desirable that applications that dynamically link to Qt continue to run without recompiling even after the Qt library is upgraded/replaced with another version. For example, if your application <em>CuteApp</em> was based on Qt 4.5, you should be able to upgrade the Qt libraries (on Windows shipped with the application, on Linux often comes from package manager automatically!) from version 4.5 to Qt 4.6 and your CuteApp that was built with Qt 4.5 should still be able to run.</p>
<p>在设计像 Qt 这样的库时，即使在 Qt 库升级/替换为另一个版本之后，动态链接到 Qt 的应用程序也希望在不重新编译的情况下继续运行。 例如，如果您的应用程序 CuteApp 基于 Qt 4.5，您应该能够将 Qt 库（在应用程序附带的 Windows 上，在 Linux 上通常自动来自包管理器！）从版本 4.5 升级到 Qt 4.6 和您的 CuteApp 用 Qt 4.5 构建的应该仍然可以运行。</p>
<h3 id="What-breaks-binary-compatibility"><a href="#What-breaks-binary-compatibility" class="headerlink" title="What breaks binary compatibility?"></a>What breaks binary compatibility?</h3><p>So, when does a change in the library require a recompilation of the application? Let’s take a simple example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    Rect m_geometry;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_text;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">String</span> m_text;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>Here we have a Widget that contains geometry as a member variable. We compile our Widget and ship it as <em>WidgetLib 1.0</em>.</p>
<p>For <em>WidgetLib 1.1</em>, someone comes up with the bright idea to add support for stylesheets. No sweat, we just add new methods and add a new <em>data member</em>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     Rect m_geometry;</span><br><span class="line">     <span class="keyword">String</span> m_stylesheet; <span class="comment">// NEW in WidgetLib 1.1</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">     <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> m_text;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">String</span> m_text;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>We ship WidgetLib 1.1 with the above change only to find that CuteApp that was compiled and ran just fine with WidgetLib 1.0 crashes gloriously!</p>
<h3 id="Why-did-it-crash"><a href="#Why-did-it-crash" class="headerlink" title="Why did it crash?"></a>Why did it crash?</h3><p>The reason is that by adding a new data member, we ended up changing the size of Widget and Label objects. Why does this matter? When your C++ compiler generates code, it uses <strong>offsets</strong> to access data within an object.</p>
<p>Here’s an oversimplified version of how the above <a href="https://en.wikipedia.org/wiki/Passive_data_structure" target="_blank" rel="noopener">POD</a> objects might look in memory.</p>
<table>
<thead>
<tr>
<th align="center">Label object layout in WidgetLib 1.0</th>
<th align="center">Label object layout in WidgetLib 1.1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">m_geometry &lt;offset 0&gt;</td>
<td align="center">m_geometry &lt;offset 0&gt;</td>
</tr>
<tr>
<td align="center">- - -</td>
<td align="center">m_stylesheet &lt;offset 1&gt;</td>
</tr>
<tr>
<td align="center">m_text &lt;offset 1&gt;</td>
<td align="center">- - -</td>
</tr>
<tr>
<td align="center">- - -</td>
<td align="center">m_text &lt;offset 2&gt;</td>
</tr>
</tbody></table>
<p>In WidgetLib 1.0, the text member of Label was at (logical) offset 1. The code generated by the compiler in the application for the method <code>Label::text()</code> translates to accessing offset 1 of the label object in the application. In WidgetLib 1.1, the <em>text</em> member of Label has shifted to (logical) offset 2! Since the application has not been recompiled, it continues to think that <code>text</code> is at offset 1 and ends up accessing the <code>stylesheet</code> variable!</p>
<p>I am sure at this point there are a few who are wondering why the <code>Label::text()</code>‘s offset calculation code ended up in the CuteApp binary and not in the WidgetLib binary. The answer is that the code for <code>Label::text()</code> was defined in the header file and the compiler ended up <em><a href="http://en.wikipedia.org/wiki/Inline_function" target="_blank" rel="noopener">inlining</a></em> it.</p>
<p>So, does the situation change if <code>Label::text()</code> had not been inlined? Say, <code>Label::text()</code> was moved to the source file? Well, no. The C++ compiler relies on the size of objects being the same at compile time and run-time. For example, stack winding/unwinding - if you created a Label object on the stack, the compiler generated code to allocate space on the stack based on the Label’s size at compile time. Since the size of Label is different at run time in WidgetLib 1.1, Label’s constructor overwrites existing stack data and ends up corrupting the stack.</p>
<p>在 WidgetLib 1.0 中，Label 的文本成员位于（逻辑）偏移量 1。编译器在应用程序中为方法 Label::text() 生成的代码转换为访问应用程序中标签对象的偏移量 1。在 WidgetLib 1.1 中，Label 的文本成员已移动到（逻辑）偏移量 2！由于应用程序尚未重新编译，它继续认为文本位于偏移量 1 并最终访问样式表变量！</p>
<p>我敢肯定，在这一点上，有些人想知道为什么 Label::text() 的偏移量计算代码最终出现在 CuteApp 二进制文件中，而不是 WidgetLib 二进制文件中。答案是 Label::text() 的代码是在头文件中定义的，编译器最终内联了它。</p>
<p>那么，如果 Label::text() 没有被内联，情况会改变吗？说，Label::text() 被移动到源文件？嗯，不。 C++ 编译器依赖于对象的大小在编译时和运行时相同。例如，堆栈卷绕/展开 - 如果您在堆栈上创建了一个标签对象，编译器会生成代码以在编译时根据标签的大小在堆栈上分配空间。由于在 WidgetLib 1.1 中运行时 Label 的大小不同，Label 的构造函数会覆盖现有的堆栈数据并最终破坏堆栈。</p>
<h3 id="Never-change-the-size-of-an-exported-C-class"><a href="#Never-change-the-size-of-an-exported-C-class" class="headerlink" title="Never change the size of an exported C++ class"></a>Never change the size of an exported C++ class</h3><p>In summary, never ever change the size or layout (don’t move the data around) of <em>exported</em> (i.e visible to the user) C++ classes once your library has been released. A C++ compiler generates code assuming that the size or the ordering of data in a class does not change <em>after</em> the application has been compiled.</p>
<p>So, how can one not change the size of the object and yet add new features?</p>
<p>总之，一旦你的库发布，永远不要改变导出的（即对用户可见的）C++ 类的大小或布局（不要移动数据）。 C++ 编译器生成代码时假定类中数据的大小或顺序在应用程序编译完成后不会改变。</p>
<p>那么，如何既不改变对象的大小又增加新的特征呢？</p>
<h3 id="The-d-pointer"><a href="#The-d-pointer" class="headerlink" title="The d-pointer"></a>The d-pointer</h3><p>The trick is to keep the size of all public classes of a library constant by only storing a single pointer. This pointer points to a private/internal data structure that contains all the data. The size of this internal structure can shrink or grow without having any side-effect on the application because the pointer is accessed only in the library code and from the application’s point of view the size of the object never changes - it’s always the size of the pointer. This pointer is called the d-pointer.</p>
<p>The spirit of this pattern is outlined in the code below (all code in this article doesn’t have destructors, of course you should add them in real code).</p>
<p>诀窍是通过仅存储单个指针来保持库的所有公共类的大小不变。 该指针指向包含所有数据的私有/内部数据结构。 这个内部结构的大小可以缩小或增长，而不会对应用程序产生任何副作用，因为指针只能在库代码中访问，从应用程序的角度来看，对象的大小永远不会改变 - 它始终是 指针。 该指针称为 d 指针。</p>
<p>这种模式的精神在下面的代码中进行了概述（本文中的所有代码都没有析构函数，当然你应该在实际代码中添加它们）。</p>
<h4 id="widget-h"><a href="#widget-h" class="headerlink" title="widget.h"></a><strong>widget.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Since d_ptr is a pointer and is never referended in header file</span></span><br><span class="line"><span class="comment">(it would cause a compile error) WidgetPrivate doesn't have to be included,</span></span><br><span class="line"><span class="comment">but forward-declared instead.</span></span><br><span class="line"><span class="comment">The definition of the class can be written in widget.cpp or</span></span><br><span class="line"><span class="comment">in a separate file, say widget_p.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetPrivate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Rect <span class="title">geometry</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-p-h"><a href="#widget-p-h" class="headerlink" title="widget_p.h"></a><strong>widget_p.h</strong></h4><p>which is the private header file of the widget class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* widget_p.h (_p means private) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Rect geometry;</span><br><span class="line">    <span class="keyword">String</span> stylesheet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp"><a href="#widget-cpp" class="headerlink" title="widget.cpp"></a><strong>widget.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With this #include, we can access WidgetPrivate.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget_p.h"</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget() : d_ptr(<span class="keyword">new</span> WidgetPrivate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Creation of private data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">Widget::geometry</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The d-ptr is only accessed in the library code</span></span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;geometry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, there’s an example of a child class based on Widget.</p>
<h4 id="label-h"><a href="#label-h" class="headerlink" title="label.h"></a><strong>label.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Each class maintains its own d-pointer</span></span><br><span class="line">    LabelPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="label-cpp"><a href="#label-cpp" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike WidgetPrivate, the author decided LabelPrivate</span></span><br><span class="line"><span class="comment">// to be defined in the source file itself</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LabelPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::Label() : d_ptr(<span class="keyword">new</span> LabelPrivate)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">Label::text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;<span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With the above structure, CuteApp never accesses the d-pointer directly. And since the <em>d-pointer</em> is only ever accessed in WidgetLib and WidgetLib is recompiled for every release, the Private class can freely change with no impact on CuteApp.</p>
<p>使用上述结构，CuteApp 永远不会直接访问 d 指针。 由于 d-pointer 只能在 WidgetLib 中访问，并且每次发布都会重新编译 WidgetLib，因此 Private 类可以自由更改，而不会影响 CuteApp。</p>
<h3 id="Other-benefits-of-d-pointer"><a href="#Other-benefits-of-d-pointer" class="headerlink" title="Other benefits of d-pointer"></a>Other benefits of d-pointer</h3><p>It’s not all about binary compatibility. The d-pointer has other benefits:</p>
<ul>
<li>Hide implementation details - We can ship WidgetLib with just the header files and the binaries. The .cpp files can be closed source.</li>
<li>The header file is clean of implementation details and can serve as the API reference.</li>
<li>Since the header files needed for implementation are moved from the header file into the implementation (source) file, compiles are much faster.</li>
</ul>
<p>It is indeed true that the above benefits appear trivial. The real reason to use d-pointers in Qt is for binary compatibility and the fact that Qt started out closed source.</p>
<ul>
<li>隐藏实现细节 - 我们可以只使用头文件和二进制文件来发布 WidgetLib。 .cpp 文件可以是封闭源代码。</li>
<li>头文件没有实现细节，可以作为 API 参考。</li>
<li>由于实现所需的头文件从头文件移动到实现（源）文件，编译速度更快。</li>
</ul>
<p>确实，上述好处似乎微不足道。 在 Qt 中使用 d 指针的真正原因是为了二进制兼容性以及 Qt 开始是封闭源代码的事实。</p>
<h3 id="The-q-pointer"><a href="#The-q-pointer" class="headerlink" title="The q-pointer"></a>The q-pointer</h3><p>So far, we have only seen the d-pointer as a C-style data structure. In reality, it contains private methods (helper functions). For example, <code>LabelPrivate</code> might have a <code>getLinkTargetFromPoint()</code> helper function that is required to find the link target when the mouse is clicked. In many cases, these helper methods require access to the public class i.e some functions from Label or from its base class Widget. For example, a helper method, <code>setTextAndUpdateWidget()</code> might want to call <code>Widget::update()</code> which is a public method to schedule a redraw the Widget. So, the <code>WidgetPrivate</code> stores a pointer to the public class called the q-pointer. Modifying the code above for the q-pointer, we get:</p>
<p>到目前为止，我们只将 d 指针视为 C 风格的数据结构。 实际上，它包含私有方法（辅助函数）。 例如，LabelPrivate 可能有一个 getLinkTargetFromPoint() 辅助函数，当单击鼠标时需要它来查找链接目标。 在许多情况下，这些辅助方法需要访问公共类，即来自 Label 或其基类 Widget 的一些函数。 例如，一个辅助方法 setTextAndUpdateWidget() 可能想要调用 Widget::update() 这是一个公共方法来安排重绘 Widget。 因此，WidgetPrivate 存储了一个指向名为 q-pointer 的公共类的指针。 修改上面的 q-pointer 代码，我们得到：</p>
<h4 id="widget-h-1"><a href="#widget-h-1" class="headerlink" title="widget.h"></a><strong>widget.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetPrivate</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">Rect <span class="title">geometry</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-p-h-1"><a href="#widget-p-h-1" class="headerlink" title="widget_p.h"></a><strong>widget_p.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Constructor that initializes the q-ptr</span></span><br><span class="line">    WidgetPrivate(Widget *q) : q_ptr(q) &#123; &#125;</span><br><span class="line">    Widget *q_ptr; <span class="comment">// q-ptr points to the API class</span></span><br><span class="line">    Rect geometry;</span><br><span class="line">    <span class="keyword">String</span> stylesheet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp-1"><a href="#widget-cpp-1" class="headerlink" title="widget.cpp"></a><strong>widget.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget_p.h"</span></span></span><br><span class="line"><span class="comment">// Create private data.</span></span><br><span class="line"><span class="comment">// Pass the 'this' pointer to initialize the q-ptr</span></span><br><span class="line">Widget::Widget() : d_ptr(<span class="keyword">new</span> WidgetPrivate(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">Widget::geometry</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// the d-ptr is only accessed in the library code</span></span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;geometry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, another class based on Widget.</p>
<h4 id="label-h-1"><a href="#label-h-1" class="headerlink" title="label.h"></a><strong>label.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">text</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LabelPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="label-cpp-1"><a href="#label-cpp-1" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike WidgetPrivate, the author decided LabelPrivate</span></span><br><span class="line"><span class="comment">// to be defined in the source file itself</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LabelPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LabelPrivate(Label *q) : q_ptr(q) &#123; &#125;</span><br><span class="line">    Label *q_ptr;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::Label() : d_ptr(<span class="keyword">new</span> LabelPrivate(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">Label::text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d_ptr-&gt;<span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inheriting-d-pointers-for-optimization"><a href="#Inheriting-d-pointers-for-optimization" class="headerlink" title="Inheriting d-pointers for optimization"></a>Inheriting d-pointers for optimization</h3><p>In the above code, creating a single Label results in the memory allocation for <code>LabelPrivate</code> and <code>WidgetPrivate</code>. If we were to employ this strategy for Qt, the situation becomes quite worse for classes like <code>QListWidget</code> - it is 6 levels deep in the class inheritance hierarchy and it would result in upto 6 memory allocations!</p>
<p>This is solved by having an inheritance hierarchy for our <em>private</em> classes and having the class getting instantiated pass on a the d-pointer all the way up.</p>
<p>Notice that when inheriting d-pointers, the declaration of the private class has to be in a separate file, for example widget_p.h. It’s no longer possible to declare it in the widget.cpp file.</p>
<p>在上面的代码中，创建单个 Label 会导致 LabelPrivate 和 WidgetPrivate 的内存分配。 如果我们对 Qt 采用这种策略，那么对于像 QListWidget 这样的类，情况会变得更糟——它在类继承层次结构中有 6 层，最多会导致 6 次内存分配！</p>
<p>这可以通过为我们的私有类建立一个继承层次结构并让被实例化的类一直传递到 d 指针来解决。</p>
<p>请注意，当继承 d 指针时，私有类的声明必须在单独的文件中，例如 widget_p.h。 不再可能在 widget.cpp 文件中声明它。</p>
<h4 id="widget-h-2"><a href="#widget-h-2" class="headerlink" title="widget.h"></a><strong>widget.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// only subclasses may access the below</span></span><br><span class="line">    <span class="comment">// allow subclasses to initialize with their own concrete Private</span></span><br><span class="line">    Widget(WidgetPrivate &amp;d);</span><br><span class="line">    WidgetPrivate *d_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-p-h-2"><a href="#widget-p-h-2" class="headerlink" title="widget_p.h"></a><strong>widget_p.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WidgetPrivate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WidgetPrivate(Widget *q) : q_ptr(q) &#123; &#125; <span class="comment">// constructor that initializes the q-ptr</span></span><br><span class="line">    Widget *q_ptr; <span class="comment">// q-ptr that points to the API class</span></span><br><span class="line">    Rect geometry;</span><br><span class="line">    <span class="keyword">String</span> stylesheet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="widget-cpp-2"><a href="#widget-cpp-2" class="headerlink" title="widget.cpp"></a><strong>widget.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget::Widget() : d_ptr(<span class="keyword">new</span> WidgetPrivate(<span class="keyword">this</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::Widget(WidgetPrivate &amp;d) : d_ptr(&amp;d)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="label-h-2"><a href="#label-h-2" class="headerlink" title="label.h"></a><strong>label.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span> :</span> <span class="keyword">public</span> Widget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Label();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Label(LabelPrivate &amp;d); <span class="comment">// allow Label subclasses to pass on their Private</span></span><br><span class="line">    <span class="comment">// notice how Label does not have a d_ptr! It just uses Widget's d_ptr.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="label-cpp-2"><a href="#label-cpp-2" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget_p.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabelPrivate</span> :</span> <span class="keyword">public</span> WidgetPrivate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Label::Label()</span><br><span class="line"> : Widget(*<span class="keyword">new</span> LabelPrivate) <span class="comment">// initialize the d-pointer with our own Private</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Label::Label(LabelPrivate &amp;d) : Widget(d)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Do you see the beauty? When we now create a <code>Label</code> object, it will create a <code>LabelPrivate</code> (which subclasses <code>WidgetPrivate</code>). It passes on the concrete <em>d-pointer</em> to Widget’s protected constructor! Now, when a <code>Label</code> object is created, there is only one memory allocation. Label also has a protected constructor that can be used by its subclasses to provide their own private classes.</p>
<p>你看到美了吗？ 当我们现在创建一个 Label 对象时，它将创建一个 LabelPrivate（它是 WidgetPrivate 的子类）。 它将具体的 d 指针传递给 Widget 的受保护构造函数！ 现在，当一个 Label 对象被创建时，只有一个内存分配。 Label 还有一个受保护的构造函数，它的子类可以使用它来提供它们自己的私有类。</p>
<h3 id="d-pointers-in-Qt"><a href="#d-pointers-in-Qt" class="headerlink" title="d-pointers in Qt"></a>d-pointers in Qt</h3><p>In Qt, practically every public class uses the d-pointer approach. The only cases where it’s not used is when it is known in advance that the class will never ever have extra member variables added to it. For example, for classes like <code>QPoint</code>, <code>QRect</code>, no new members are expected to be added and hence the data members are stored straight into the class itself instead of using the d-pointer.</p>
<p>Notice that in Qt, the base class of all Private objects is <code>QObjectPrivate</code>.</p>
<p>在 Qt 中，几乎每个公共类都使用 d 指针方法。 唯一不使用它的情况是事先知道该类永远不会添加额外的成员变量。 例如，对于像 QPoint、QRect 这样的类，不需要添加新成员，因此数据成员直接存储到类本身中，而不是使用 d 指针。</p>
<p>请注意，在 Qt 中，所有 Private 对象的基类都是 QObjectPrivate。</p>
<h3 id="Q-D-and-Q-Q"><a href="#Q-D-and-Q-Q" class="headerlink" title="Q_D and Q_Q"></a>Q_D and Q_Q</h3><p>A side effect of the optimization that we did in the previous step is that the q-ptr and d-ptr are of type <code>Widget</code> and <code>WidgetPrivate</code>. This means that the following won’t work.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::setText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">String</span> &amp;<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// won't work! since d_ptr is of type WidgetPrivate even though</span></span><br><span class="line">   <span class="comment">// it points to LabelPrivate object</span></span><br><span class="line">   d_ptr-&gt;<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hence, when accessing the d-pointer in a subclass, we need to static_cast to the appropriate type.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::setText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">String</span> &amp;<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LabelPrivate *d = <span class="keyword">static_cast</span>&lt;LabelPrivate*&gt;(d_ptr); <span class="comment">// cast to our private type</span></span><br><span class="line">    d-&gt;<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, it’s not pretty having static_cast all over the place. Instead, there are two macros defined in src/corelib/global/qglobal.h which make it straighforward:</p>
<h4 id="global-h"><a href="#global-h" class="headerlink" title="global.h"></a><strong>global.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_D(Class) Class##Private * const d = d_func()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_Q(Class) Class * const q = q_func()</span></span><br></pre></td></tr></table></figure>

<h4 id="label-cpp-3"><a href="#label-cpp-3" class="headerlink" title="label.cpp"></a><strong>label.cpp</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With Q_D you can use the members of LabelPrivate from Label</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Label::setText</span><span class="params">(<span class="keyword">const</span> <span class="keyword">String</span> &amp;<span class="built_in">text</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_D(Label);</span><br><span class="line">    d-&gt;<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With Q_Q you can use the members of Label from LabelPrivate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LabelPrivate::someHelperFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q_Q(Label);</span><br><span class="line">    q-&gt;selectAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Q-DECLARE-PRIVATE-and-Q-DECLARE-PUBLIC"><a href="#Q-DECLARE-PRIVATE-and-Q-DECLARE-PUBLIC" class="headerlink" title="Q_DECLARE_PRIVATE and Q_DECLARE_PUBLIC"></a>Q_DECLARE_PRIVATE and Q_DECLARE_PUBLIC</h3><p>Qt classes have a <code>Q_DECLARE_PRIVATE</code> macro in the public class. The macro reads:</p>
<h4 id="qglobal-h"><a href="#qglobal-h" class="headerlink" title="qglobal.h"></a><strong>qglobal.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PRIVATE(Class)\</span></span><br><span class="line">    <span class="keyword">inline</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> </span>&#123;\</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr));\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;\</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> Class##Private *&gt;(qGetPtrHelper(d_ptr));\</span><br><span class="line">    &#125;\</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>##<span class="title">Private</span>;</span></span><br></pre></td></tr></table></figure>

<p>This macro can be used this way:</p>
<h4 id="qlabel-h"><a href="#qlabel-h" class="headerlink" title="qlabel.h"></a><strong>qlabel.h</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QLabel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Q_DECLARE_PRIVATE(QLabel)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The idea is that <code>QLabel</code> provides a function <code>d_func()</code> that allows access to its private internal class. The method itself is private (since the macro is inside a private section in qlabel.h). The <code>d_func()</code> can however be invoked by <strong>friends</strong> (C++ friend) of <code>QLabel</code>. This is primarily useful for access of information by Qt classes which cannot get access of some <code>QLabel</code> information using public api. As a bizarre example, <code>QLabel</code> might keep track of how many times the user has clicked on a link. However, there is no public API to access this information. <code>QStatistics</code> is a class that needs this information. A Qt developer will add <code>QStatistics</code> as a friend of <code>QLabel</code> and <code>QStatistics</code> can then do <code>label-&gt;d_func()-&gt;linkClickCount</code>.</p>
<p>The <code>d_func</code> also has the advantage to enforce const-correctness: In a const member function of MyClass you need a <code>Q_D(const MyClass)</code> and thus you can only call const member functions in MyClassPrivate. With a <em>naked</em> d_ptr you could also call non-const functions.</p>
<p>这个想法是 QLabel 提供了一个函数 d_func() 允许访问其私有内部类。 该方法本身是私有的（因为宏位于 qlabel.h 的私有部分中）。 然而 d_func() 可以被 QLabel 的朋友（C++ 朋友）调用。 这主要用于通过 Qt 类访问信息，这些类无法使用公共 api 访问某些 QLabel 信息。 作为一个奇怪的例子，QLabel 可能会跟踪用户点击链接的次数。 但是，没有公共 API 可以访问此信息。 QStatistics 是一个需要此信息的类。 Qt 开发人员会将 QStatistics 添加为 QLabel 的朋友，然后 QStatistics 可以执行 label-&gt;d_func()-&gt;linkClickCount。</p>
<p>d_func 还具有强制 const 正确性的优点：在 MyClass 的 const 成员函数中，您需要 Q_D(const MyClass)，因此您只能在 MyClassPrivate 中调用 const 成员函数。 使用裸 d_ptr 您还可以调用非常量函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/20/QThread-general-usage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/20/QThread-general-usage/" class="post-title-link" itemprop="url">QThread general usage</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-20 22:20:40" itemprop="dateCreated datePublished" datetime="2022-09-20T22:20:40+08:00">2022-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-24 12:14:49" itemprop="dateModified" datetime="2022-09-24T12:14:49+08:00">2022-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/QT/" itemprop="url" rel="index"><span itemprop="name">QT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Threads in an operating system are a very simple thing. Write a function, maybe bundle it with some data and push it onto a newly created thread. Use a mutex or other method to safely communicate with the thread if necessary. Whether it are Win32, POSIX or other threads, they all basically work the same and are quite fool-proof.</p>
<p>操作系统中的线程是一件非常简单的事情。 编写一个函数，或许将它与一些数据捆绑在一起并将其推送到一个新创建的线程上。 如有必要，使用互斥锁或其他方法安全地与线程通信。 无论是Win32、POSIX还是其他线程，基本上都是一样的，而且相当的万无一失。</p>
<p>Those who have discovered the joys of the Qt framework may assume that threads in Qt are just like this, and they would be right. However, there are several different ways to use threads in Qt, and it might not be obvious which approach to choose. The article, <a href="http://doc.qt.io/qt-5/threads-technologies.html" target="_blank" rel="noopener">Multithreading Technologies in Qt</a>, compares the different approaches.</p>
<p>那些发现 Qt 框架的乐趣的人可能会认为 Qt 中的线程就是这样，他们是对的。 然而，在 Qt 中使用线程有几种不同的方法，选择哪种方法可能并不明显。 Qt 中的多线程技术一文比较了不同的方法。</p>
<p>The rest of this article demonstrates one of these methods: <strong>QThread + a worker QObject</strong>. This method is intended for use cases which involve event-driven programming and signals + slots across threads.</p>
<p>本文的其余部分演示了其中一种方法：QThread + 一个worker QObject。 此方法适用于涉及事件驱动编程和跨线程信号 + 槽的用例。</p>
<h3 id="Usage-with-Worker-class"><a href="#Usage-with-Worker-class" class="headerlink" title="Usage with Worker class"></a>Usage with Worker class</h3><p>The main thing in this example to keep in mind when using a QThread is that it’s not a thread. It’s a wrapper around a thread object. This wrapper provides the signals, slots and methods to easily use the thread object within a Qt project. To use it, prepare a QObject subclass with all your desired functionality in it. Then create a new QThread instance, push the QObject onto it using moveToThread(QThread*) of the QObject instance and call start() on the QThread instance. That’s all. You set up the proper signal/slot connections to make it quit properly and such, and that’s all.</p>
<p>在这个例子中使用 QThread 时要记住的主要事情是它不是线程。 它是一个线程对象的包装器。 这个包装器提供了信号、槽和方法，以便在 Qt 项目中轻松使用线程对象。 要使用它，请准备一个 QObject 子类，其中包含您想要的所有功能。 然后创建一个新的 QThread 实例，使用 QObject 实例的 moveToThread(QThread*) 将 QObject 推送到其上，并在 QThread 实例上调用 start()。 就这样。 您设置了正确的信号/插槽连接以使其正确退出等等，仅此而已。</p>
<h4 id="Declare-Worker-class"><a href="#Declare-Worker-class" class="headerlink" title="Declare Worker class"></a>Declare Worker class</h4><p>For a basic example, check this class declaration for the Worker class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Worker();</span><br><span class="line">    ~Worker();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(QString err)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// add your variables here</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We add at least one public slot which will be used to trigger the instance and make it start processing data once the thread has started. Now, let’s see what the implementation for this basic class looks like.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Worker::Worker() &#123; <span class="comment">// Constructor</span></span><br><span class="line">    <span class="comment">// you could copy data from constructor arguments to internal variables here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Worker::~Worker() &#123; <span class="comment">// Destructor</span></span><br><span class="line">    <span class="comment">// free resources</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker::process</span><span class="params">()</span> </span>&#123; <span class="comment">// Process. Start processing data.</span></span><br><span class="line">    <span class="comment">// allocate resources using new here</span></span><br><span class="line">    qDebug(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="function">emit <span class="title">finished</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>While this Worker class doesn’t do anything special, it nevertheless contains all the required elements. It starts processing when its main function, in this case process(), is called and when it is done it emits the signal finished() which will then be used to trigger the shutdown of the QThread instance it is contained in.</p>
<p>虽然这个 Worker 类没有做任何特别的事情，但它仍然包含所有必需的元素。 当它的主函数（在本例中为 process()）被调用时，它开始处理，当它完成时，它发出信号 finished()，然后将用于触发它所在的 QThread 实例的关闭。</p>
<p>By the way, one extremely important thing to note here is that you should NEVER allocate heap objects (using new) in the constructor of the QObject class as this allocation is then performed on the main thread and not on the new QThread instance, meaning that the newly created object is then owned by the main thread and not the QThread instance. This will make your code fail to work. Instead, allocate such resources in the main function slot such as process() in this case as when that is called the object will be on the new thread instance and thus it will own the resource.</p>
<p>顺便说一句，这里要注意的一件非常重要的事情是，您永远不应该在 QObject 类的构造函数中分配堆对象（使用 new），因为这种分配是在主线程上执行的，而不是在新的 QThread 实例上执行的，这意味着 然后，新创建的对象归主线程所有，而不是 QThread 实例。 这将使您的代码无法正常工作。 相反，在这种情况下，在诸如 process() 之类的主函数槽中分配此类资源，因为当调用该对象时，该对象将位于新线程实例上，因此它将拥有该资源。</p>
<h4 id="Create-a-new-Worker-instance"><a href="#Create-a-new-Worker-instance" class="headerlink" title="Create a new Worker instance"></a>Create a new Worker instance</h4><p>Now, let’s see how to use this new construction by creating a new Worker instance and putting it on a QThread instance:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QThread* thread = <span class="keyword">new</span> QThread();</span><br><span class="line">Worker* worker = <span class="keyword">new</span> Worker();</span><br><span class="line">worker-&gt;moveToThread(thread);</span><br><span class="line"><span class="built_in">connect</span>( worker, &amp;Worker::error, <span class="keyword">this</span>, &amp;MyClass::errorString);</span><br><span class="line"><span class="built_in">connect</span>( thread, &amp;QThread::started, worker, &amp;Worker::<span class="built_in">process</span>);</span><br><span class="line"><span class="built_in">connect</span>( worker, &amp;Worker::finished, thread, &amp;QThread::quit);</span><br><span class="line"><span class="built_in">connect</span>( worker, &amp;Worker::finished, worker, &amp;Worker::deleteLater);</span><br><span class="line"><span class="built_in">connect</span>( thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);</span><br><span class="line">thread-&gt;start();</span><br></pre></td></tr></table></figure>

<p>The connect() series here is the most crucial part. The first connect() line hooks up the error message signal from the worker to an error processing function in the main thread. The second connects the thread’s started() signal to the processing() slot in the worker, causing it to start.</p>
<p>这里的connect()系列是最关键的部分。 第一个 connect() 行将来自 worker 的错误消息信号连接到主线程中的错误处理函数。 第二个将线程的 started() 信号连接到 worker 中的 processing() 槽，使其启动。</p>
<p>Then the clean-up: when the worker instance emits finished(), as we did in the example, it will signal the thread to quit, i.e. shut down. We then mark the worker instance using the same finished() signal for deletion. Finally, to prevent nasty crashes because the thread hasn’t fully shut down yet when it is deleted, we connect the finished() of the thread (not the worker!) to its own deleteLater() slot. This will cause the thread to be deleted only after it has fully shut down.</p>
<p>然后进行清理：当worker实例发出finished()时，就像我们在示例中所做的那样，它将发出线程退出的信号，即关闭。 然后，我们使用相同的 finished() 信号标记工作实例以进行删除。 最后，为了防止由于线程在被删除时尚未完全关闭而导致的严重崩溃，我们将线程（不是工作线程！）的finished() 连接到它自己的deleteLater() 槽。 这将导致线程仅在完全关闭后才被删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/17/Hexo%E5%86%99%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/Hexo%E5%86%99%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">超详细Hexo+Github博客搭建小白教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-17 13:56:14" itemprop="dateCreated datePublished" datetime="2022-09-17T13:56:14+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-24 12:14:21" itemprop="dateModified" datetime="2022-09-24T12:14:21+08:00">2022-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index"><span itemprop="name">hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文链接:<a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在<code>D:\study\program\blog</code>目录下。</p>
<p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p>
<p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p>
<p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>
<p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p>
<p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="https://link.zhihu.com/?target=http%3A//localhost%3A4000/">http://localhost:4000/</a>，就可以看到我们的博客啦.</p>
<p>按<code>ctrl+c</code>关闭本地服务器。</p>
<h2 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h2><p>首先右键打开git bash，然后输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"godweiyang"</span></span><br><span class="line">git config --global user.email <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></figure>

<p>用户名和邮箱根据你注册github的信息自行修改。</p>
<p>然后生成密钥SSH key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"792321264@qq.com"</span></span><br></pre></td></tr></table></figure>

<p>打开<a href="https://link.zhihu.com/?target=http%3A//github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p>
<p>git bash中输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>将输出的内容复制到框中，点击确定保存。</p>
<p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p>
<p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p>
<p>修改最后一行的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/godweiyang/godweiyang.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repository修改为你自己的github项目地址。</p>
<h2 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。</p>
<p>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p>
<p>然后打开<code>D:\study\program\blog\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p>
<p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>把下载的主题的文件放在theme目录下，<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/releases</a></p>
<p>修改配置文件主题为当前主题名字。</p>
<p>然后运行<code>hexo clean</code>清空所有生成的网页缓存，<code>hexo g</code>、<code>hexo d</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
